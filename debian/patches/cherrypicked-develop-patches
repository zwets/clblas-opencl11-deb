--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -76,16 +76,6 @@
 set_property( CACHE OPENCL_VERSION PROPERTY STRINGS 2.0 1.2 1.1 )
 message( STATUS "You have confirmed OpenCL ${OPENCL_VERSION} is supported in your system" )
 
-# By default test-correctness is linked and tested against ACML library.
-# However, test-correctness can instead use NETLIB as a reference library
-# On Mac OSX systems, this must be set to OFF for the build to succeed (due to nesting of FindBLAS code)
-if ( APPLE )
-	set(CORR_TEST_WITH_ACML OFF CACHE BOOL "Use ACML library in correctness tests")
-else ( )
-	message(STATUS "CORR_TEST_WITH_ACML set to OFF. Try link with libblas.so")
-	set(CORR_TEST_WITH_ACML OFF CACHE BOOL "Use ACML library in correctness tests")
-endif( )
-
 if( CMAKE_GENERATOR MATCHES "NMake" )
   option( NMAKE_COMPILE_VERBOSE "Print compile and link strings to the console" OFF )
   if( NMAKE_COMPILE_VERBOSE )
@@ -96,12 +86,16 @@
 endif( )
 
 # If we are on linux, and we wish to link with the netlib BLAS implementation when BUILD_TEST is ON, we need to have a valid fortran compiler
-if(BUILD_TEST AND NOT CORR_TEST_WITH_ACML AND NOT WIN32 AND NOT APPLE)
+if((BUILD_TEST OR BUILD_CLIENT) AND (NOT WIN32 AND NOT APPLE))
   project(clBLAS Fortran C CXX )
 else( )
   project(clBLAS C CXX)
 endif( )
 
+if( CORR_TEST_WITH_ACML )
+  message( WARNING "Linking with ACML has been removed; please link netlib or accelerate" )
+endif( )
+
 # Define a version for the code
 if( NOT DEFINED clBLAS_VERSION_MAJOR )
     set( clBLAS_VERSION_MAJOR 2 )
@@ -126,7 +120,7 @@
 # On windows, it's convenient to change the default install prefix such that it does NOT point to 'program files' (permissions problems)
 # Need to check out CMAKE_RUNTIME_OUTPUT_DIRECTORY variable, and see if that eliminates the need to modify install path
 if( WIN32 AND CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT )
-	set( CMAKE_INSTALL_PREFIX "${PROJECT_BINARY_DIR}/package" CACHE PATH "Install path prefix, prepended onto install directories" FORCE )
+  set( CMAKE_INSTALL_PREFIX "${PROJECT_BINARY_DIR}/package" CACHE PATH "Install path prefix, prepended onto install directories" FORCE )
 endif( )
 
 if(NOT CMAKE_BUILD_TYPE)
@@ -171,112 +165,45 @@
 
 # add the math library for Linux
 if( UNIX )
-    set(MATH_LIBRARY "m")
-    set(THREAD_LIBRARY "pthread")
+  set(MATH_LIBRARY "m")
+  set(THREAD_LIBRARY "pthread")
 endif()
 
 # set the path to specific OpenCL compiler
 set( OPENCL_COMPILER_DIR "OPENCL COMPILER PATH" CACHE PATH "OPENCL COMPILER PATH")
 if ( ${OPENCL_COMPILER_DIR} STREQUAL "OPENCL COMPILER PATH")
     message( STATUS "Using default OpenCL Compiler")
-	  set(ENV_PATH "$ENV{PATH}")
+    set(ENV_PATH "$ENV{PATH}")
 else ()
     message( STATUS "OPENCL COMPILER: ${OPENCL_COMPILER_DIR}")
-	if(UNIX)
-	  set(ENV_PATH "${OPENCL_COMPILER_DIR}")
-	else()
-	  set(ENV_PATH "${OPENCL_COMPILER_DIR}")
-	endif()
+  if(UNIX)
+    set(ENV_PATH "${OPENCL_COMPILER_DIR}")
+  else()
+    set(ENV_PATH "${OPENCL_COMPILER_DIR}")
+  endif()
 endif()
 
 # Find the BLAS library
 # TODO: maybe this could be written using the FindBLAS module in the future
-if( BUILD_TEST )
-	if(NOT CORR_TEST_WITH_ACML)
-	    if(APPLE)
-			find_library(BLAS_LIBRARIES Accelerate HINTS /System/Library/Frameworks/Accelerate.framework)
-		       	MARK_AS_ADVANCED(BLAS_LIBRARIES)
-		       	message(STATUS "Using Accelerate framework on Mac OS-X")
-	    else()
-			find_package( Netlib COMPONENTS BLAS REQUIRED )
-        endif()
-		else( )
-		# Find ACML BLAS implementation
-		# platform dependent ACML subdirectory
-		if (WIN32)
-			set(ACML_SUBDIR ifort${TARGET_PLATFORM}_mp)
-		else()
-		   set(ACML_SUBDIR gfortran${TARGET_PLATFORM}_mp)
-		endif()
-
-		find_path(ACML_INCLUDE_DIRS acml.h
-			HINTS
-				${ACML_ROOT}/include
-				${ACML_ROOT}/${ACML_SUBDIR}/include
-				$ENV{ACML_ROOT}/include
-                                $ENV{ACML_ROOT}/${ACML_SUBDIR}/include
-		)
-
-		if( ACML_INCLUDE_DIRS )
-		else()
-			message(WARNING "Cannot find acml.h")
-		endif()
-
-		if( UNIX )
-			find_library(ACML_LIBRARIES acml_mp
-				HINTS
-					${ACML_ROOT}/lib
-					${ACML_ROOT}/${ACML_SUBDIR}/lib
-					$ENV{ACML_ROOT}/lib
-                                        $ENV{ACML_ROOT}/${ACML_SUBDIR}/lib
-			)
-			find_library(_acml_mv_library acml_mv
-				HINTS
-					${ACML_ROOT}/lib
-					${ACML_ROOT}/${ACML_SUBDIR}/lib
-					$ENV{ACML_ROOT}/lib
-                                        $ENV{ACML_ROOT}/${ACML_SUBDIR}/lib
-			)
-			mark_as_advanced(_acml_mv_library)
-		endif( )
-
-		if(WIN32)
-			find_library(ACML_LIBRARIES libacml_mp_dll
-				HINTS
-					${ACML_ROOT}/lib
-					${ACML_ROOT}/${ACML_SUBDIR}/lib
-					$ENV{ACML_ROOT}/lib
-                                        $ENV{ACML_ROOT}/${ACML_SUBDIR}/lib
-			)
-		endif( )
-
-		if( NOT ACML_LIBRARIES )
-			message(WARNING "Cannot find libacml")
-		endif( )
-
-		if(ACML_INCLUDE_DIRS AND ACML_LIBRARIES)
-			if(_acml_mv_library)
-				list(APPEND ACML_LIBRARIES ${_acml_mv_library})
-			endif()
-			message(STATUS "Found ACML: ${ACML_LIBRARIES}")
-			set(ACML_FOUND TRUE BOOL "Found the ACML package")
-		endif()
-		mark_as_advanced(ACML_FOUND ACML_INCLUDE_DIRS ACML_LIBRARIES)
-
-	endif( )
+if( BUILD_TEST OR BUILD_CLIENT )
+  if( APPLE )
+    find_library(BLAS_LIBRARIES Accelerate HINTS /System/Library/Frameworks/Accelerate.framework)
+   	MARK_AS_ADVANCED(BLAS_LIBRARIES)
+   	message(STATUS "Using Accelerate framework on Mac OS-X")
+  else()
+    # The client applications does not actually link netlib blas on WIN32
+    if( NOT WIN32 )
+      find_package( Netlib COMPONENTS BLAS REQUIRED )
+    endif( )
+  endif( )
 endif( )
 
-if( BUILD_CLIENT )
-    find_package( Netlib COMPONENTS BLAS REQUIRED )
-endif()
-
-
 # This will define OPENCL_FOUND
 find_package( OpenCL ${OPENCL_VERSION} )
 
 # Find Boost on the system, and configure the type of boost build we want
 set( Boost_USE_MULTITHREADED ON )
-set( Boost_USE_STATIC_LIBS   OFF )
+set( Boost_USE_STATIC_LIBS   ON )
 set( Boost_DETAILED_FAILURE_MSG   ON )
 # set( Boost_DEBUG ON )
 set( Boost_ADDITIONAL_VERSIONS "1.44.0" "1.44" "1.47.0" "1.47" "1.60.0" "1.60" )
@@ -286,10 +213,10 @@
 
 
 if( NOT Boost_FOUND )
-	message( STATUS "The clBLAS ktest requires boost to be installed" )
-	set( BUILD_KTEST OFF )
-	message( STATUS "The clBLAS client requires boost to be installed" )
-	set( BUILD_CLIENT OFF )
+  message( STATUS "The clBLAS ktest requires boost to be installed" )
+  set( BUILD_KTEST OFF )
+  message( STATUS "The clBLAS client requires boost to be installed" )
+  set( BUILD_CLIENT OFF )
 endif()
 
 # Turn on maximum compiler verbosity
@@ -302,16 +229,28 @@
     # Don't use -rpath.
     set(CMAKE_SKIP_RPATH ON CACHE BOOL "Skip RPATH" FORCE)
 
+    # Need to determine the target machine of the C compiler, because
+    # the '-m32' and '-m64' flags are supported on x86 but not on e.g. ARM.
+    exec_program( "${CMAKE_C_COMPILER} -dumpmachine"
+        OUTPUT_VARIABLE CMAKE_C_COMPILER_MACHINE )
+    message( STATUS "CMAKE_C_COMPILER_MACHINE: ${CMAKE_C_COMPILER_MACHINE}" )
+    # The "86" regular expression matches x86, x86_64, i686, etc.
+    if(${CMAKE_C_COMPILER_MACHINE} MATCHES "86")
+        set(CMAKE_C_FLAGS "-m${TARGET_PLATFORM} ${CMAKE_C_FLAGS}")
+        set(CMAKE_CXX_FLAGS "-m${TARGET_PLATFORM} ${CMAKE_CXX_FLAGS}")
+        set(CMAKE_Fortran_FLAGS "-m${TARGET_PLATFORM} ${CMAKE_Fortran_FLAGS}")
+    endif()
+
     if(TARGET_PLATFORM EQUAL 32)
         set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fno-builtin")
     endif()
 elseif(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
     set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wno-narrowing")
 elseif( MSVC )
-	# CMake sets huge stack frames for windows, for whatever reason.  We go with compiler default.
-	string( REGEX REPLACE "/STACK:[0-9]+" "" CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS}" )
-	string( REGEX REPLACE "/STACK:[0-9]+" "" CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS}" )
-	string( REGEX REPLACE "/STACK:[0-9]+" "" CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS}" )
+  # CMake sets huge stack frames for windows, for whatever reason.  We go with compiler default.
+  string( REGEX REPLACE "/STACK:[0-9]+" "" CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS}" )
+  string( REGEX REPLACE "/STACK:[0-9]+" "" CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS}" )
+  string( REGEX REPLACE "/STACK:[0-9]+" "" CMAKE_MODULE_LINKER_FLAGS "${CMAKE_MODULE_LINKER_FLAGS}" )
 endif( )
 
 if (WIN32)
@@ -325,49 +264,49 @@
 
 # configure a header file to pass the CMake version settings to the source, and package the header files in the output archive
 install( FILES
-			"clBLAS.h"
-			"clAmdBlas.h"
-			"clAmdBlas.version.h"
-			"clBLAS-complex.h"
-			"${PROJECT_BINARY_DIR}/include/clBLAS.version.h"
-		DESTINATION
-			"./include" )
+  "clBLAS.h"
+  "clAmdBlas.h"
+  "clAmdBlas.version.h"
+  "clBLAS-complex.h"
+  "${PROJECT_BINARY_DIR}/include/clBLAS.version.h"
+  DESTINATION
+  "./include" )
 
 
 if( BUILD_CLIENT AND IS_DIRECTORY "${PROJECT_SOURCE_DIR}/client")
-	add_subdirectory( client )
+  add_subdirectory( client )
 endif( )
 
 if( BUILD_PERFORMANCE AND IS_DIRECTORY "${PROJECT_SOURCE_DIR}/scripts/perf" )
-	add_subdirectory( scripts/perf )
+  add_subdirectory( scripts/perf )
 endif( )
 
 if( BUILD_RUNTIME AND IS_DIRECTORY "${PROJECT_SOURCE_DIR}/library" )
 #	add_subdirectory( library/tools/bingen )
-	add_subdirectory( library )
-	add_subdirectory( library/tools/tune )
-	if( BUILD_KTEST )
-		add_subdirectory( library/tools/ktest )
-	endif( )
+  add_subdirectory( library )
+  add_subdirectory( library/tools/tune )
+  if( BUILD_KTEST )
+  add_subdirectory( library/tools/ktest )
+  endif( )
 endif()
 
 if( BUILD_SAMPLE AND IS_DIRECTORY "${PROJECT_SOURCE_DIR}/samples" )
-	add_subdirectory( samples )
+  add_subdirectory( samples )
 endif( )
 
 # The build server is not supposed to build or package any of the tests; build server script will define this on the command line with
 # cmake -G "Visual Studio 10 Win64" -D BUILDSERVER:BOOL=ON ../..
 if( BUILD_TEST )
-	if( IS_DIRECTORY "${PROJECT_SOURCE_DIR}/tests" )
-		add_subdirectory(tests)
-	endif( )
-
-	# These tests #include <getopts.h>, which is not windows compliant
-	if (NOT WIN32 AND IS_DIRECTORY "${PROJECT_SOURCE_DIR}/library" )
-		add_subdirectory( library/blas/gens/tests )
-		add_subdirectory( library/blas/gens/legacy/tests )
-		add_subdirectory( library/common/tests )
-	endif( )
+  if( IS_DIRECTORY "${PROJECT_SOURCE_DIR}/tests" )
+  add_subdirectory(tests)
+  endif( )
+
+  # These tests #include <getopts.h>, which is not windows compliant
+  if (NOT WIN32 AND IS_DIRECTORY "${PROJECT_SOURCE_DIR}/library" )
+  add_subdirectory( library/blas/gens/tests )
+  add_subdirectory( library/blas/gens/legacy/tests )
+  add_subdirectory( library/common/tests )
+  endif( )
 endif( )
 
 if(WIN32)
@@ -392,17 +331,17 @@
 
 # The following code is setting variables to control the behavior of CPack to generate our
 if( WIN32 )
-	set( CPACK_SOURCE_GENERATOR "ZIP" )
-	set( CPACK_GENERATOR "ZIP" )
+  set( CPACK_SOURCE_GENERATOR "ZIP" )
+  set( CPACK_GENERATOR "ZIP" )
 else( )
-	set( CPACK_SOURCE_GENERATOR "TGZ" )
-	set( CPACK_GENERATOR "TGZ" )
+  set( CPACK_SOURCE_GENERATOR "TGZ" )
+  set( CPACK_GENERATOR "TGZ" )
 endif( )
 
 if( TARGET_PLATFORM EQUAL 64 )
-	set( CPACK_PACKAGE_FILE_NAME "${CMAKE_PROJECT_NAME}-${clBLAS_VERSION}-${CMAKE_HOST_SYSTEM_NAME}-x64")
+  set( CPACK_PACKAGE_FILE_NAME "${CMAKE_PROJECT_NAME}-${clBLAS_VERSION}-${CMAKE_HOST_SYSTEM_NAME}-x64")
 else( )
-	set( CPACK_PACKAGE_FILE_NAME "${CMAKE_PROJECT_NAME}-${clBLAS_VERSION}-${CMAKE_HOST_SYSTEM_NAME}-x32")
+  set( CPACK_PACKAGE_FILE_NAME "${CMAKE_PROJECT_NAME}-${clBLAS_VERSION}-${CMAKE_HOST_SYSTEM_NAME}-x32")
 endif( )
 
 set( CPACK_SOURCE_PACKAGE_FILE_NAME "${CMAKE_PROJECT_NAME}-${clBLAS_VERSION}-${CMAKE_HOST_SYSTEM_NAME}-Source")
--- a/src/library/CMakeLists.txt
+++ b/src/library/CMakeLists.txt
@@ -24,14 +24,14 @@
 
 # AutoGemm scripts and out files
 set(AUTOGEMM_SCRIPTS
-  ${CMAKE_SOURCE_DIR}/library/blas/AutoGemm/AutoGemm.py
-  ${CMAKE_SOURCE_DIR}/library/blas/AutoGemm/AutoGemmParameters.py
-  ${CMAKE_SOURCE_DIR}/library/blas/AutoGemm/Common.py
-  ${CMAKE_SOURCE_DIR}/library/blas/AutoGemm/Includes.py
-  ${CMAKE_SOURCE_DIR}/library/blas/AutoGemm/KernelOpenCL.py
-  ${CMAKE_SOURCE_DIR}/library/blas/AutoGemm/KernelParameters.py
-  ${CMAKE_SOURCE_DIR}/library/blas/AutoGemm/KernelSelection.py
-  ${CMAKE_SOURCE_DIR}/library/blas/AutoGemm/KernelsToPreCompile.py
+  ${CMAKE_CURRENT_SOURCE_DIR}/blas/AutoGemm/AutoGemm.py
+  ${CMAKE_CURRENT_SOURCE_DIR}/blas/AutoGemm/AutoGemmParameters.py
+  ${CMAKE_CURRENT_SOURCE_DIR}/blas/AutoGemm/Common.py
+  ${CMAKE_CURRENT_SOURCE_DIR}/blas/AutoGemm/Includes.py
+  ${CMAKE_CURRENT_SOURCE_DIR}/blas/AutoGemm/KernelOpenCL.py
+  ${CMAKE_CURRENT_SOURCE_DIR}/blas/AutoGemm/KernelParameters.py
+  ${CMAKE_CURRENT_SOURCE_DIR}/blas/AutoGemm/KernelSelection.py
+  ${CMAKE_CURRENT_SOURCE_DIR}/blas/AutoGemm/KernelsToPreCompile.py
 )
 set(AUTOGEMM_HEADERS
   ${CMAKE_BINARY_DIR}/include/AutoGemmIncludes/AutoGemmClKernels.h
@@ -54,22 +54,22 @@
 )
 
 set(USERGEMM_SRC
-  ${CMAKE_SOURCE_DIR}/library/blas/AutoGemm/UserGemmKernelSources/UserGemmClKernels.cc
+  ${CMAKE_CURRENT_SOURCE_DIR}/blas/AutoGemm/UserGemmKernelSources/UserGemmClKernels.cc
 )
 
 set(USERGEMM_HEADERS
-   ${CMAKE_SOURCE_DIR}/library/blas/AutoGemm/UserGemmKernelSources/UserGemmKernelSourceIncludes.h
-   ${CMAKE_SOURCE_DIR}/library/blas/AutoGemm/UserGemmKernelSources/UserGemmClKernels.h
+   ${CMAKE_CURRENT_SOURCE_DIR}/blas/AutoGemm/UserGemmKernelSources/UserGemmKernelSourceIncludes.h
+   ${CMAKE_CURRENT_SOURCE_DIR}/blas/AutoGemm/UserGemmKernelSources/UserGemmClKernels.h
 )
 
 set(AUTOGEMM_TEST_SRC
-  ${CMAKE_SOURCE_DIR}/library/blas/AutoGemm/AutoGemmTools/TestAutoGemm.cpp
+  ${CMAKE_CURRENT_SOURCE_DIR}/blas/AutoGemm/AutoGemmTools/TestAutoGemm.cpp
 )
 set(AUTOGEMM_PROFILER_SRC
-  ${CMAKE_SOURCE_DIR}/library/blas/AutoGemm/AutoGemmTools/ProfileAutoGemm.cpp
+  ${CMAKE_CURRENT_SOURCE_DIR}/blas/AutoGemm/AutoGemmTools/ProfileAutoGemm.cpp
 )
 set(AUTOGEMM_PRECOMPILE_SRC
-  ${CMAKE_SOURCE_DIR}/library/blas/AutoGemm/AutoGemmTools/AutoGemmPreCompileKernels.cpp
+  ${CMAKE_CURRENT_SOURCE_DIR}/blas/AutoGemm/AutoGemmTools/AutoGemmPreCompileKernels.cpp
 )
 set( AUTOGEMM_PRECOMPILED_KERNELS
   ${CMAKE_BINARY_DIR}/include/AutoGemmKernelBinaries/AutoGemmKernelBinariesPreCompiled.h
@@ -200,11 +200,11 @@
 ################################################################################
 # add target for generating pre-compile WhichKernels header
 ################################################################################
-set( AUTOGEMM_PRECOMPILE_HEADER_SRC ${CMAKE_SOURCE_DIR}/library/blas/AutoGemm/KernelsToPreCompile.py )
+set( AUTOGEMM_PRECOMPILE_HEADER_SRC ${CMAKE_CURRENT_SOURCE_DIR}/blas/AutoGemm/KernelsToPreCompile.py )
 set( AUTOGEMM_PRECOMPILE_HEADER_OUT ${CMAKE_BINARY_DIR}/include/AutoGemmIncludes/AutoGemmKernelsToPreCompile.h )
 add_custom_command(
   OUTPUT ${AUTOGEMM_PRECOMPILE_HEADER_OUT}
-  COMMAND ${PYTHON_EXECUTABLE} ${CMAKE_SOURCE_DIR}/library/blas/AutoGemm/KernelsToPreCompile.py ${AGPC_ARGS}
+  COMMAND ${PYTHON_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/blas/AutoGemm/KernelsToPreCompile.py ${AGPC_ARGS}
   DEPENDS ${AUTOGEMM_PRECOMPILE_HEADER_SRC}
 )
 
@@ -245,14 +245,14 @@
 ################################################################################
 add_custom_command(
   OUTPUT ${AUTOGEMM_HEADERS} ${AUTOGEMM_SRC}
-  COMMAND ${PYTHON_EXECUTABLE} ${CMAKE_SOURCE_DIR}/library/blas/AutoGemm/AutoGemm.py --output-path ${CMAKE_BINARY_DIR}/include --opencl-compiler-version ${OPENCL_VERSION} --architecture ${AUTOGEMM_ARCHITECTURE}
+  COMMAND ${PYTHON_EXECUTABLE} ${CMAKE_CURRENT_SOURCE_DIR}/blas/AutoGemm/AutoGemm.py --output-path ${CMAKE_BINARY_DIR}/include --opencl-compiler-version ${OPENCL_VERSION} --architecture ${AUTOGEMM_ARCHITECTURE}
   DEPENDS ${AUTOGEMM_SCRIPTS}
 )
 
 
 include_directories(
     ${OPENCL_INCLUDE_DIRS}
-    ${CMAKE_SOURCE_DIR}
+    ${CMAKE_CURRENT_SOURCE_DIR}/..
     ${CMAKE_BINARY_DIR}/include
     .
 )
@@ -692,7 +692,7 @@
 
 include( ExternalProject )
 ExternalProject_Add( tplgen
-    URL "${CMAKE_SOURCE_DIR}/library/tools/tplgen"
+    URL "${CMAKE_CURRENT_SOURCE_DIR}/tools/tplgen"
     INSTALL_COMMAND ""
 )
 
@@ -701,7 +701,7 @@
 
 
 ExternalProject_Add( OCLBinaryGenerator
-	URL "${CMAKE_SOURCE_DIR}/library/tools/OCLBinaryGenerator"
+	URL "${CMAKE_CURRENT_SOURCE_DIR}/tools/OCLBinaryGenerator"
 	CMAKE_ARGS -DOPENCL_LIBRARIES=${OPENCL_LIBRARIES} -DOPENCL_INCLUDE_DIRS=${OPENCL_INCLUDE_DIRS}
 	INSTALL_COMMAND ""
 )
@@ -723,8 +723,8 @@
 add_custom_target( OCLBinaryGenerator_GEN )
 add_custom_command(TARGET OCLBinaryGenerator_GEN
                    PRE_BUILD
-				   COMMAND ${CMAKE_COMMAND} -DOCLBinaryGeneratorBinaryDir=${OCLBinaryGeneratorBinaryDir} -DSOURCE_DIR=${CMAKE_SOURCE_DIR} -DBINARY_DIR=${CMAKE_BINARY_DIR} -DOCL_COMPILER_FLAGS=${OCL_COMPILER_FLAGS}
-				   -P "${CMAKE_SOURCE_DIR}/library/OCLBinaryGenerator.cmake"
+				   COMMAND ${CMAKE_COMMAND} -DOCLBinaryGeneratorBinaryDir=${OCLBinaryGeneratorBinaryDir} -DSOURCE_DIR=${CMAKE_CURRENT_SOURCE_DIR}/.. -DBINARY_DIR=${CMAKE_BINARY_DIR} -DOCL_COMPILER_FLAGS=${OCL_COMPILER_FLAGS}
+				   -P "${CMAKE_CURRENT_SOURCE_DIR}/OCLBinaryGenerator.cmake"
 				   )
 add_dependencies( OCLBinaryGenerator_GEN OCLBinaryGenerator )
 
@@ -733,7 +733,7 @@
 # if offline compilation is not chosen, bingen should not be built
 if(OPENCL_OFFLINE_BUILD_TAHITI_KERNEL OR OPENCL_OFFLINE_BUILD_HAWAII_KERNEL OR OPENCL_OFFLINE_BUILD_BONAIRE_KERNEL)
 	ExternalProject_Add( bingen
-		URL "${CMAKE_SOURCE_DIR}/library/tools/bingen"
+		URL "${CMAKE_CURRENT_SOURCE_DIR}/tools/bingen"
 		CMAKE_ARGS -DOPENCL_LIBRARIES=${OPENCL_LIBRARIES} -DOPENCL_INCLUDE_DIRS=${OPENCL_INCLUDE_DIRS}
 		INSTALL_COMMAND ""
 	)
@@ -741,10 +741,10 @@
 
 message(STATUS "OPENCL_VERSION = ${OPENCL_VERSION}")
 #if( OPENCL_VERSION STREQUAL "2.0")
-#	if(EXISTS ${CMAKE_SOURCE_DIR}/flags.txt)
+#	if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/../flags.txt)
 #		MESSAGE(STATUS "flags.txt found. will load AMD_OPENCL_BUILD_OPTIONS_APPEND from it.")
 #		set (LOAD_CL_FLAGS TRUE)
-#		file (STRINGS "${CMAKE_SOURCE_DIR}/flags.txt" OPENCL_FLAGS)
+#		file (STRINGS "${CMAKE_CURRENT_SOURCE_DIR}/../flags.txt" OPENCL_FLAGS)
 #		MESSAGE(STATUS "OCLFLAGS: ${OPENCL_FLAGS}")
 #		string(REPLACE "OCL " "OCL;" OPENCL_FLAGS_REPLACED ${OPENCL_FLAGS})
 #		list(GET OPENCL_FLAGS_REPLACED 1 OPENCL_FLAGS_REPLACED_1)#flags for TAHITI
@@ -752,10 +752,10 @@
 #		list(GET OPENCL_FLAGS_REPLACED 5 OPENCL_FLAGS_REPLACED_5)#flags for HAWAII 2
 #		list(GET OPENCL_FLAGS_REPLACED 7 OPENCL_FLAGS_REPLACED_7)#flags for BONAIRE
 #		#MESSAGE("${OPENCL_FLAGS_REPLACED_7}")
-#	elseif(EXISTS ${CMAKE_SOURCE_DIR}/flags_public.txt)
+#	elseif(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/../flags_public.txt)
 #		MESSAGE(STATUS "flags_public.txt found. will load AMD_OPENCL_BUILD_OPTIONS_APPEND from it.")
 #		set (LOAD_CL_FLAGS TRUE)
-#		file (STRINGS "${CMAKE_SOURCE_DIR}/flags_public.txt" OPENCL_FLAGS)
+#		file (STRINGS "${CMAKE_CURRENT_SOURCE_DIR}/../flags_public.txt" OPENCL_FLAGS)
 #		MESSAGE(STATUS "OCLFLAGS: ${OPENCL_FLAGS}")
 #		string(REPLACE "OCL " "OCL;" OPENCL_FLAGS_REPLACED ${OPENCL_FLAGS})
 #		list(GET OPENCL_FLAGS_REPLACED 1 OPENCL_FLAGS_REPLACED_1)#flags for TAHITI
@@ -789,21 +789,21 @@
 add_custom_target( GEN_CLBIN )
 add_custom_command(TARGET GEN_CLBIN
                    PRE_BUILD
-				   COMMAND ${CMAKE_COMMAND} -DbingenBinaryDir=${bingenBinaryDir} -DCLTEMPLATE_PATH="${CMAKE_SOURCE_DIR}/library/blas/gens/clTemplates"
+				   COMMAND ${CMAKE_COMMAND} -DbingenBinaryDir=${bingenBinaryDir} -DCLTEMPLATE_PATH="${CMAKE_CURRENT_SOURCE_DIR}/blas/gens/clTemplates"
 	               -DLOAD_CL_FLAGS=${LOAD_CL_FLAGS} -DTAHITI_FLAG=${OPENCL_FLAGS_REPLACED_1} -DHAWAII1_FLAG=${OPENCL_FLAGS_REPLACED_3} -DHAWAII2_FLAG=${OPENCL_FLAGS_REPLACED_5} -DBONAIRE_FLAG=${OPENCL_FLAGS_REPLACED_7}
 				   -DENV_PATH=${ENV_PATH} -DOPENCL_OFFLINE_BUILD_HAWAII_KERNEL=${OPENCL_OFFLINE_BUILD_HAWAII_KERNEL} -DOPENCL_OFFLINE_BUILD_BONAIRE_KERNEL=${OPENCL_OFFLINE_BUILD_BONAIRE_KERNEL}
 				   -DOPENCL_OFFLINE_BUILD_TAHITI_KERNEL=${OPENCL_OFFLINE_BUILD_TAHITI_KERNEL}
-				   -P "${CMAKE_SOURCE_DIR}/library/bingen.cmake"
+				   -P "${CMAKE_CURRENT_SOURCE_DIR}/bingen.cmake"
 				   )
 add_dependencies( GEN_CLBIN bingen )
 else()
 add_custom_target( GEN_CLBIN )
 add_custom_command(TARGET GEN_CLBIN
                    PRE_BUILD
-				   COMMAND ${CMAKE_COMMAND} -DbingenBinaryDir=${bingenBinaryDir} -DCLTEMPLATE_PATH="${CMAKE_SOURCE_DIR}/library/blas/gens/clTemplates"
+				   COMMAND ${CMAKE_COMMAND} -DbingenBinaryDir=${bingenBinaryDir} -DCLTEMPLATE_PATH="${CMAKE_CURRENT_SOURCE_DIR}/blas/gens/clTemplates"
 				   -DOPENCL_OFFLINE_BUILD_HAWAII_KERNEL=${OPENCL_OFFLINE_BUILD_HAWAII_KERNEL} -DOPENCL_OFFLINE_BUILD_BONAIRE_KERNEL=${OPENCL_OFFLINE_BUILD_BONAIRE_KERNEL}
 				   -DOPENCL_OFFLINE_BUILD_TAHITI_KERNEL=${OPENCL_OFFLINE_BUILD_TAHITI_KERNEL}
-				   -P "${CMAKE_SOURCE_DIR}/library/bingen.cmake"
+				   -P "${CMAKE_CURRENT_SOURCE_DIR}/bingen.cmake"
 				   )
 add_dependencies( GEN_CLBIN bingen )
 endif()
@@ -819,9 +819,9 @@
 endif()
 
 add_custom_target( GENERATE_CLT
-    COMMAND ${tplgenBinaryDir}/tplgen -o ${clBLAS_BINARY_DIR}/include -i ${CMAKE_SOURCE_DIR}/library/blas/gens/clTemplates/ ${SRC_CL_TEMPLATES}
+    COMMAND ${tplgenBinaryDir}/tplgen -o ${clBLAS_BINARY_DIR}/include -i ${CMAKE_CURRENT_SOURCE_DIR}/blas/gens/clTemplates/ ${SRC_CL_TEMPLATES}
     COMMAND ${tplgenBinaryDir}/tplgen -o ${clBLAS_BINARY_DIR}/include -i ${bingenBinaryDir}/ ${SRC_CL_TEMPLATES_GEN}
-    #WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/library/blas/gens/clTemplates
+    #WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/blas/gens/clTemplates
 	WORKING_DIRECTORY ${bingenBinaryDir}
 )
 
--- a/src/library/blas/AutoGemm/AutoGemmTools/AutoGemmPreCompileKernels.cpp
+++ b/src/library/blas/AutoGemm/AutoGemmTools/AutoGemmPreCompileKernels.cpp
@@ -40,7 +40,12 @@
 #define stat _stat
 #endif
 
-#include "CL/opencl.h"
+#ifdef __APPLE__
+#include <OpenCL/opencl.h>
+#else
+#include <CL/cl.h>
+#endif
+
 //#include "naive_blas.cpp"
 //using namespace NaiveBlas;
 #include "AutoGemmIncludes/AutoGemmKernelsToPreCompile.h"
--- a/src/library/blas/AutoGemm/KernelOpenCL.py
+++ b/src/library/blas/AutoGemm/KernelOpenCL.py
@@ -359,13 +359,7 @@
   numBLoadsR = (kernel.workGroupNumCols*kernel.microTileNumCols*kernel.unroll) \
       % (kernel.workGroupNumRows*kernel.workGroupNumCols)
 
-  # TODO - zeroString for real and complex
-  if kernel.precision == "c":
-    zeroString = "(float2)(0.f, 0.f)"
-  elif kernel.precision == "z":
-    zeroString = "(double2)(0.0, 0.0)"
-  else:
-    zeroString = "0.0"
+  zeroString = "(DATA_TYPE_STR)(0)"
   for a in range(0, int(numALoads)):
     kStr += "    lA[ %d*localAStride ] = " % a
     if kernel.isRowKernel():
--- a/src/library/blas/AutoGemm/UserGemmKernelSources/UserGemmClKernels.cc
+++ b/src/library/blas/AutoGemm/UserGemmKernelSources/UserGemmClKernels.cc
@@ -13,6 +13,10 @@
 cl_kernel sgemm_Col_NN_B1_MX032_NX032_KX16_BRANCH_clKernel = NULL;
 cl_kernel sgemm_Col_NT_B1_MX032_NX032_KX16_BRANCH_clKernel = NULL;
 cl_kernel sgemm_Col_TN_B1_MX032_NX032_KX16_BRANCH_clKernel = NULL;
+cl_kernel dgemm_NN_gfx906_tensile_clKernel = NULL;
+cl_kernel dgemm_NT_gfx906_tensile_clKernel = NULL;
+cl_kernel dgemm_TN_gfx906_tensile_clKernel = NULL;
+cl_kernel dgemm_TT_gfx906_tensile_clKernel = NULL;
 
 #ifdef __cplusplus
 extern "C" {
@@ -51,4 +55,20 @@
         clReleaseKernel(sgemm_Col_TN_B1_MX032_NX032_KX16_BRANCH_clKernel);
         sgemm_Col_TN_B1_MX032_NX032_KX16_BRANCH_clKernel = NULL;
     }
+    if(dgemm_NN_gfx906_tensile_clKernel != NULL) {
+        clReleaseKernel(dgemm_NN_gfx906_tensile_clKernel);
+        dgemm_NN_gfx906_tensile_clKernel = NULL;
+    }
+    if(dgemm_NT_gfx906_tensile_clKernel != NULL) {
+        clReleaseKernel(dgemm_NT_gfx906_tensile_clKernel);
+        dgemm_NT_gfx906_tensile_clKernel = NULL;
+    }
+    if(dgemm_TN_gfx906_tensile_clKernel != NULL) {
+        clReleaseKernel(dgemm_TN_gfx906_tensile_clKernel);
+        dgemm_TN_gfx906_tensile_clKernel = NULL;
+    }
+    if(dgemm_TT_gfx906_tensile_clKernel != NULL) {
+        clReleaseKernel(dgemm_TT_gfx906_tensile_clKernel);
+        dgemm_TT_gfx906_tensile_clKernel = NULL;
+    }
 }
--- a/src/library/blas/AutoGemm/UserGemmKernelSources/UserGemmClKernels.h
+++ b/src/library/blas/AutoGemm/UserGemmKernelSources/UserGemmClKernels.h
@@ -18,7 +18,12 @@
 extern cl_kernel sgemm_Col_NT_B1_MX032_NX032_KX16_BRANCH_clKernel;
 extern cl_kernel sgemm_Col_TN_B1_MX032_NX032_KX16_BRANCH_clKernel;
 
-static const int user_kernel_count = 7;
+extern cl_kernel dgemm_NN_gfx906_tensile_clKernel;
+extern cl_kernel dgemm_NT_gfx906_tensile_clKernel;
+extern cl_kernel dgemm_TN_gfx906_tensile_clKernel;
+extern cl_kernel dgemm_TT_gfx906_tensile_clKernel;
+
+static const int user_kernel_count = 11;
 
 #ifdef __cplusplus
 extern "C" {
--- a/src/library/blas/AutoGemm/UserGemmKernelSources/UserGemmKernelSourceIncludes.cpp
+++ b/src/library/blas/AutoGemm/UserGemmKernelSources/UserGemmKernelSourceIncludes.cpp
@@ -48,6 +48,11 @@
 #include "UserGemmKernelSources/sgemm_Col_NT_B1_MX032_NX032_KX16_BRANCH_src.cpp"
 #include "UserGemmKernelSources/sgemm_Col_TN_B1_MX032_NX032_KX16_BRANCH_src.cpp"
 
+//**** Special kernels for vega20 from tensile lib
+#include "UserGemmKernelSources/dgemm_NN_gfx906_tensile_src.cpp"
+#include "UserGemmKernelSources/dgemm_NT_gfx906_tensile_src.cpp"
+#include "UserGemmKernelSources/dgemm_TN_gfx906_tensile_src.cpp"
+#include "UserGemmKernelSources/dgemm_TT_gfx906_tensile_src.cpp"
 
 //**** compiler flags
 //**** online compilation flags
--- a/src/library/blas/AutoGemm/UserGemmKernelSources/UserGemmKernelSourceIncludes.h
+++ b/src/library/blas/AutoGemm/UserGemmKernelSources/UserGemmKernelSourceIncludes.h
@@ -77,4 +77,36 @@
 extern unsigned char *sgemm_Col_TN_B1_MX032_NX032_KX16_BRANCH_bin;
 extern size_t sgemm_Col_TN_B1_MX032_NX032_KX16_BRANCH_binSize;
 
+extern const unsigned int dgemm_NN_gfx906_tensile_workGroupNumRows;
+extern const unsigned int dgemm_NN_gfx906_tensile_workGroupNumCols;
+extern const unsigned int dgemm_NN_gfx906_tensile_microTileNumRows;
+extern const unsigned int dgemm_NN_gfx906_tensile_microTileNumCols;
+extern const char * const dgemm_NN_gfx906_tensile_src;
+extern unsigned char *dgemm_NN_gfx906_tensile_bin;
+extern size_t dgemm_NN_gfx906_tensile_binSize;
+
+extern const unsigned int dgemm_NT_gfx906_tensile_workGroupNumRows;
+extern const unsigned int dgemm_NT_gfx906_tensile_workGroupNumCols;
+extern const unsigned int dgemm_NT_gfx906_tensile_microTileNumRows;
+extern const unsigned int dgemm_NT_gfx906_tensile_microTileNumCols;
+extern const char * const dgemm_NT_gfx906_tensile_src;
+extern unsigned char *dgemm_NT_gfx906_tensile_bin;
+extern size_t dgemm_NT_gfx906_tensile_binSize;
+
+extern const unsigned int dgemm_TN_gfx906_tensile_workGroupNumRows;
+extern const unsigned int dgemm_TN_gfx906_tensile_workGroupNumCols;
+extern const unsigned int dgemm_TN_gfx906_tensile_microTileNumRows;
+extern const unsigned int dgemm_TN_gfx906_tensile_microTileNumCols;
+extern const char * const dgemm_TN_gfx906_tensile_src;
+extern unsigned char *dgemm_TN_gfx906_tensile_bin;
+extern size_t dgemm_TN_gfx906_tensile_binSize;
+
+extern const unsigned int dgemm_TT_gfx906_tensile_workGroupNumRows;
+extern const unsigned int dgemm_TT_gfx906_tensile_workGroupNumCols;
+extern const unsigned int dgemm_TT_gfx906_tensile_microTileNumRows;
+extern const unsigned int dgemm_TT_gfx906_tensile_microTileNumCols;
+extern const char * const dgemm_TT_gfx906_tensile_src;
+extern unsigned char *dgemm_TT_gfx906_tensile_bin;
+extern size_t dgemm_TT_gfx906_tensile_binSize;
+
 #endif
--- /dev/null
+++ b/src/library/blas/AutoGemm/UserGemmKernelSources/dgemm_NN_gfx906_tensile_src.cpp
@@ -0,0 +1,663 @@
+/*******************************************************************************
+ * Hand-tuned kernel
+ ******************************************************************************/
+
+#ifndef KERNEL_DGEMM_NN_GFX906_TENSILE_SRC_H
+#define KERNEL_DGEMM_NN_GFX906_TENSILE_SRC_H
+// #pragma message("AutoGemm's dgemm_NN_gfx906_tensile_src overriden by user.")
+
+const unsigned int dgemm_NN_gfx906_tensile_workGroupNumRows = 16;
+const unsigned int dgemm_NN_gfx906_tensile_workGroupNumCols = 16;
+const unsigned int dgemm_NN_gfx906_tensile_microTileNumRows = 4;
+const unsigned int dgemm_NN_gfx906_tensile_microTileNumCols = 4;
+
+#ifndef STRINGIFY
+#define STRINGIFY(S) STRINGIFY2(S)
+#define STRINGIFY2(S) #S
+#endif
+
+//if precompiled is enabled. All hand tuned kerenls should be precompiled.
+#ifndef AUTOGEMM_USE_PRE_COMPILED_KERNELS
+unsigned char *dgemm_NN_gfx906_tensile_bin = 0;
+size_t dgemm_NN_gfx906_tensile_binSize = 0;
+#endif
+
+const char * const dgemm_NN_gfx906_tensile_src = STRINGIFY(
+/******************************************/
+/* Function Prefix                        */
+/******************************************/
+
+/* tile parameters */
+#define NUM_THREADS 256
+#define SG0I 16
+#define SG1J 16
+#define TT0I 4
+#define TT1J 4
+#define MT0I (SG0I*TT0I)
+#define MT1J (SG1J*TT1J)
+#define VECTOR_WIDTH 2
+#define GLOBAL_LOAD_VECTOR_WIDTH_A 1
+#define GLOBAL_LOAD_VECTOR_WIDTH_B 1
+#define GLOBAL_WRITE_VECTOR_WIDTH 2
+
+/* DepthU parameters*/
+#define CPSV (NUM_THREADS / MT0I * VECTOR_WIDTH)
+#define LOCAL_SPLITU 1
+#define UNROLL 4
+#define LOCAL_DEPTHU (LOCAL_SPLITU*UNROLL)
+
+/* other */
+#define PAD 0
+#define WORK_GROUP_MAPPING 2
+
+/* num loads parallel and perpendicular to coalesced */
+#define NLCA 1
+#define NLCB 1
+#define NLPA 1
+#define NLPB 1
+
+/* load sizes parallel and perpendicular to coalesced */
+#define LSCA (MT0I/NLCA)
+#define LSPA (LOCAL_DEPTHU/NLPA)
+#define LSCB (LOCAL_DEPTHU/NLCB)
+#define LSPB (MT1J/NLPB)
+#define LVCA (LSCA/GLOBAL_LOAD_VECTOR_WIDTH_A)
+#define LVCB (LSCB/GLOBAL_LOAD_VECTOR_WIDTH_B)
+#define LVPA (LSPA/GLOBAL_LOAD_VECTOR_WIDTH_A)
+#define LVPB (LSPB/GLOBAL_LOAD_VECTOR_WIDTH_B)
+#define LDS_OFFSET_B 256
+#define LDS_NUM_ELEMENTS 1024
+#define LDS_OFFSET_BLK 512
+
+/* global memory indices */
+#define GLOBAL_C(IDX0I, IDX1J, IDXK) (( (IDX0I)*strideC0I + (IDX1J)*strideC1J + (IDXK)*strideCK ))
+#define GLOBAL_OFFSET_A(IDX0I, IDXL, IDXK) (( (IDX0I)*strideA0I + (IDXL)*strideAL + (IDXK)*strideAK ))
+#define GLOBAL_OFFSET_B(IDXL, IDX1J, IDXK) (( (IDXL)*strideBL + (IDX1J)*strideB1J + (IDXK)*strideBK ))
+
+/* data types */
+#define DATA_TYPE double
+#define MAC(A,B,DST) mad(A,B,DST)
+
+/* MAC's */
+#define TYPE_MAC(MULA,MULB,DST) DST = MAC(MULA,MULB,DST);
+#define TYPE_MAC_WRITE(DST,ALPHA,REG,BETA) DST = 0 != (BETA) ? (ALPHA)*(REG) + (BETA)*(DST) : (ALPHA)*(REG);
+
+/* 4x4 micro-tile */
+#define MAC_4x4 \
+  TYPE_MAC(rA[0],rB[0],rC[0+0*TT0I]); \
+  TYPE_MAC(rA[1],rB[0],rC[1+0*TT0I]); \
+  TYPE_MAC(rA[2],rB[0],rC[2+0*TT0I]); \
+  TYPE_MAC(rA[3],rB[0],rC[3+0*TT0I]); \
+  TYPE_MAC(rA[0],rB[1],rC[0+1*TT0I]); \
+  TYPE_MAC(rA[1],rB[1],rC[1+1*TT0I]); \
+  TYPE_MAC(rA[2],rB[1],rC[2+1*TT0I]); \
+  TYPE_MAC(rA[3],rB[1],rC[3+1*TT0I]); \
+  TYPE_MAC(rA[0],rB[2],rC[0+2*TT0I]); \
+  TYPE_MAC(rA[1],rB[2],rC[1+2*TT0I]); \
+  TYPE_MAC(rA[2],rB[2],rC[2+2*TT0I]); \
+  TYPE_MAC(rA[3],rB[2],rC[3+2*TT0I]); \
+  TYPE_MAC(rA[0],rB[3],rC[0+3*TT0I]); \
+  TYPE_MAC(rA[1],rB[3],rC[1+3*TT0I]); \
+  TYPE_MAC(rA[2],rB[3],rC[2+3*TT0I]); \
+  TYPE_MAC(rA[3],rB[3],rC[3+3*TT0I]); \
+
+/* hard-coded initial strides */
+__constant unsigned int strideC0I = 1;
+__constant unsigned int strideA0I = 1;
+__constant unsigned int strideBL = 1;
+
+  /******************************************/
+  /* Begin Kernel                           */
+  /******************************************/
+__attribute__((reqd_work_group_size(NUM_THREADS,1,1)))
+__kernel void Cijk_Ailk_Bljk_DB_MT064x064x04_K1_PGR1_PLR0_TT04_04_WG16_16_01_WGM02(
+  __global double *C,
+  __global double const * restrict A,
+  __global double const * restrict B,
+  double const alpha,
+  double const beta,
+  unsigned int const offsetC,
+  unsigned int const offsetA,
+  unsigned int const offsetB,
+  unsigned int const strideC1J,
+  unsigned int const strideCK,
+  unsigned int const strideAL,
+  unsigned int const strideAK,
+  unsigned int const strideB1J,
+  unsigned int const strideBK,
+  unsigned int const size0I,
+  unsigned int const size1J,
+  unsigned int const sizeK,
+  unsigned int const sizeL ) {
+
+  /******************************************/
+  /* Allocate Resources                     */
+  /******************************************/
+#define SCALAR_ZERO (double)(0)
+  DATA_TYPE rA[TT0I];
+  DATA_TYPE rB[TT1J];
+
+  /* registers for global->local */
+  DATA_TYPE a_0_0_0_0;
+  DATA_TYPE b_0_0_0_0;
+
+  /* allocate local memory */
+  __local DATA_TYPE localMemory[LDS_NUM_ELEMENTS];
+
+  /******************************************/
+  /* Global Read Addresses                  */
+  /******************************************/
+
+  /* global read addresses: subgroup */
+  unsigned int serial = get_local_id(0);
+  unsigned int sgId = serial / (SG0I*SG1J);
+
+  /* global read addresses: work-group */
+  unsigned int wg0I = get_group_id(0);
+  unsigned int wg1J = get_group_id(1);
+  unsigned int nwg0I = get_num_groups(0);
+  unsigned int nwg1J = get_num_groups(1);
+
+  unsigned long wgSerial = wg0I + (wg1J % WORK_GROUP_MAPPING) * nwg0I;
+  unsigned int block = wg1J / WORK_GROUP_MAPPING;
+  unsigned int blockRemainder = (wg1J < nwg1J-(nwg1J % WORK_GROUP_MAPPING) ) ? 0 : nwg1J % WORK_GROUP_MAPPING;
+  if ( blockRemainder == 0) {
+    wg0I = wgSerial / 2;
+    wg1J = wgSerial % 2 + block*WORK_GROUP_MAPPING;
+  } else {
+    wg0I = wgSerial / 1;
+    wg1J = wgSerial % 1 + block*WORK_GROUP_MAPPING;
+  }
+
+  /* global read addresses: tile offset assignment a */
+  unsigned int globalReadOffsetA0I = (serial%LVCA)*GLOBAL_LOAD_VECTOR_WIDTH_A + (wg0I)*MT0I;
+
+  /* global read addresses: tile offset assignment b */
+  unsigned int globalReadOffsetB1J = (serial/LVCB) + (wg1J)*MT1J;
+
+  /* global read addresses: unroll assignment a */
+  unsigned int globalReadOffsetAL = (serial/LVCA);
+
+  /* global read addresses: unroll assignment b */
+  unsigned int globalReadOffsetBL = (serial%LVCB)*GLOBAL_LOAD_VECTOR_WIDTH_B;
+
+  /* global read addresses: other free assignments */
+  unsigned int wgK = ( get_group_id(2) ) % sizeK;
+
+  /* global read addresses: tile offsets a */
+  unsigned int globalReadOffsetA0I_0_0 = globalReadOffsetA0I + 0 + 0*LSCA;
+
+  /* global read addresses: tile offsets b */
+  unsigned int globalReadOffsetB1J_0_0 = globalReadOffsetB1J + 0 + 0*LSPB;
+
+  /* global read addresses: unroll offsets a */
+  unsigned int globalReadOffsetAL_0_0 = globalReadOffsetAL + 0 + 0*LSPA;
+
+  /* global read addresses: unroll offsets b */
+  unsigned int globalReadOffsetBL_0_0 = globalReadOffsetBL + 0 + 0*LSCB;
+
+  /* global read addresses: shift a */
+  globalReadOffsetA0I_0_0 = (  globalReadOffsetA0I_0_0 > size0I-GLOBAL_LOAD_VECTOR_WIDTH_A+0) ? size0I-GLOBAL_LOAD_VECTOR_WIDTH_A+0 : globalReadOffsetA0I_0_0;
+
+  /* global read addresses: shift b */
+  globalReadOffsetB1J_0_0 = (  globalReadOffsetB1J_0_0 > size1J-1) ? size1J-1 : globalReadOffsetB1J_0_0;
+
+  /* global read addresses: final offsets a */
+  unsigned long globalReadOffsetA_0_0_0_0 = GLOBAL_OFFSET_A( globalReadOffsetA0I_0_0, globalReadOffsetAL_0_0, wgK );
+
+  /* global read addresses: final offsets b */
+  unsigned long globalReadOffsetB_0_0_0_0 = GLOBAL_OFFSET_B( globalReadOffsetBL_0_0, globalReadOffsetB1J_0_0, wgK );
+
+  /* global read addresses: apply user offsets */
+  C += offsetC;
+  A += offsetA;
+  B += offsetB;
+
+  /* global read addresses: addresses a */
+  __global DATA_TYPE const *globalReadA_0_0_0_0 = A + globalReadOffsetA_0_0_0_0;
+
+  /* global read addresses: addresses b */
+  __global DATA_TYPE const *globalReadB_0_0_0_0 = B + globalReadOffsetB_0_0_0_0;
+
+  /* global read addresses: increments a */
+  long globalReadIncAL = (long)strideAL*LOCAL_DEPTHU;
+
+  /* global read addresses: increments b */
+  long globalReadIncBL = (long)strideBL*LOCAL_DEPTHU;
+
+  /******************************************/
+  /* Local Write Addresses                  */
+  /******************************************/
+
+  /* local write addresses: tile assignment a */
+  unsigned int lwA0I = (serial%LVCA)*GLOBAL_LOAD_VECTOR_WIDTH_A;
+
+  /* local write addresses: tile assignment b */
+  unsigned int lwB1J = (serial/LVCB);
+
+  /* local write addresses: unroll assignment a */
+  unsigned int lwAL = (serial/LVCA);
+
+  /* local write addresses: unroll assignment b */
+  unsigned int lwBL = (serial%LVCB)*GLOBAL_LOAD_VECTOR_WIDTH_B;
+
+  /* local write addresses: first offset a */
+  unsigned int localWriteFirstOffsetA = lwA0I + lwAL*(MT0I+PAD);
+
+  /* local write addresses: first offset b */
+  unsigned int localWriteFirstOffsetB = lwB1J + lwBL*(MT1J+PAD) + LDS_OFFSET_B;
+
+  /* local write addresses: final offsets a */
+  unsigned int localWriteOffsetA_0_0_0_0 = localWriteFirstOffsetA + (0 + 0*LSCA) + (0 + 0*LSPA)*(MT0I+PAD);
+
+  /* local write addresses: final offsets b */
+  unsigned int localWriteOffsetB_0_0_0_0 = localWriteFirstOffsetB + (0 + 0*LSCB)*(MT1J+PAD) + (0 + 0*LSPB);
+
+  /* local write addresses: declare addresses a */
+  __local DATA_TYPE *localWriteA_0_0_0_0;
+
+  /* local write addresses: declare addresses b */
+  __local DATA_TYPE *localWriteB_0_0_0_0;
+
+  /* local write addresses: init pointers a */
+  localWriteA_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_0);
+
+  /* local write addresses: init pointers b */
+  localWriteB_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_0_0);
+
+  /******************************************/
+  /* Local Read Addresses                   */
+  /******************************************/
+
+  /* local read addresses: tile assignments a */
+  unsigned int lr0I = (serial % SG0I);
+
+  /* local read addresses: tile assignments b */
+  unsigned int lr1J = (serial / SG0I) % SG1J;
+
+  /* local read addresses: final offsets a */
+  unsigned int localReadOffsetA = lr0I*VECTOR_WIDTH + sgId*(MT0I+PAD);
+
+  /* local read addresses: final offsets b */
+  unsigned int localReadOffsetB = lr1J*VECTOR_WIDTH + sgId*(MT1J+PAD) + LDS_OFFSET_B;
+
+  /* local read addresses: declare addresses a */
+  __local DATA_TYPE *localReadA;
+
+  /* local read addresses: declare addresses b */
+  __local DATA_TYPE *localReadB;
+
+  /* declare loop num iterations */
+  unsigned int numIterL;
+
+  /* registers for MAC's */
+  DATA_TYPE rC[TT0I*TT1J];
+  rC[0] = SCALAR_ZERO;
+  rC[1] = SCALAR_ZERO;
+  rC[2] = SCALAR_ZERO;
+  rC[3] = SCALAR_ZERO;
+  rC[4] = SCALAR_ZERO;
+  rC[5] = SCALAR_ZERO;
+  rC[6] = SCALAR_ZERO;
+  rC[7] = SCALAR_ZERO;
+  rC[8] = SCALAR_ZERO;
+  rC[9] = SCALAR_ZERO;
+  rC[10] = SCALAR_ZERO;
+  rC[11] = SCALAR_ZERO;
+  rC[12] = SCALAR_ZERO;
+  rC[13] = SCALAR_ZERO;
+  rC[14] = SCALAR_ZERO;
+  rC[15] = SCALAR_ZERO;
+  numIterL = sizeL / LOCAL_DEPTHU;
+
+  /* local read addresses: init pointers a */
+  localReadA = (__local DATA_TYPE *)(localMemory + localReadOffsetA);
+
+  /* local read addresses: init pointers b */
+  localReadB = (__local DATA_TYPE *)(localMemory + localReadOffsetB);
+
+  /* prefetch: global -> local */
+  if (sizeL >= LOCAL_DEPTHU) {
+
+    /* global read a */
+    a_0_0_0_0 = *(globalReadA_0_0_0_0 + 0);
+
+    /* global read b */
+    b_0_0_0_0 = *(globalReadB_0_0_0_0 + 0);
+
+    /* global read inc a */
+    globalReadA_0_0_0_0 = (__global DATA_TYPE const *)( ((__global DATA_TYPE const *)globalReadA_0_0_0_0) + globalReadIncAL);
+
+    /* global read inc b */
+    globalReadB_0_0_0_0 = (__global DATA_TYPE const *)( ((__global DATA_TYPE const *)globalReadB_0_0_0_0) + globalReadIncBL);
+
+    /* local write a */
+    *(localWriteA_0_0_0_0 + 0) = a_0_0_0_0;
+
+    /* local write b */
+    *(localWriteB_0_0_0_0 + 0) = b_0_0_0_0;
+
+    /* local write swap a */
+    localWriteOffsetA_0_0_0_0 = (localWriteOffsetA_0_0_0_0 + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+
+    /* local write swap b */
+    localWriteOffsetB_0_0_0_0 = (localWriteOffsetB_0_0_0_0 + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+
+    /* local write init pointers a */
+    localWriteA_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_0);
+
+    /* local write init pointers b */
+    localWriteB_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_0_0);
+  }
+
+  /******************************************/
+  /* Unrolled Loop - Begin                  */
+  /******************************************/
+  while (numIterL-- > 1) {
+
+    /* global read a */
+    a_0_0_0_0 = *(globalReadA_0_0_0_0 + 0);
+
+    /* global read b */
+    b_0_0_0_0 = *(globalReadB_0_0_0_0 + 0);
+
+    /* global read inc a */
+    globalReadA_0_0_0_0 = (__global DATA_TYPE const *)( ((__global DATA_TYPE const *)globalReadA_0_0_0_0) + globalReadIncAL);
+
+    /* global read inc b */
+    globalReadB_0_0_0_0 = (__global DATA_TYPE const *)( ((__global DATA_TYPE const *)globalReadB_0_0_0_0) + globalReadIncBL);
+    barrier(CLK_LOCAL_MEM_FENCE);
+
+    /* iter 0 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 1 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 2 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 3 (last) */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local write a */
+    *(localWriteA_0_0_0_0 + 0) = a_0_0_0_0;
+
+    /* local write b */
+    *(localWriteB_0_0_0_0 + 0) = b_0_0_0_0;
+
+    /* local write swap offsets a */
+    localWriteOffsetA_0_0_0_0 = (localWriteOffsetA_0_0_0_0 + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+
+    /* local write swap offsets b */
+    localWriteOffsetB_0_0_0_0 = (localWriteOffsetB_0_0_0_0 + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+
+    /* local write init pointers a */
+    localWriteA_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_0);
+
+    /* local write init pointers b */
+    localWriteB_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_0_0);
+
+    /* local read swap offsets a */
+    localReadOffsetA = (localReadOffsetA + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+
+    /* local read swap offsets b */
+    localReadOffsetB = (localReadOffsetB + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+
+    /* local read init pointers a */
+    localReadA = (__local DATA_TYPE *)(localMemory + localReadOffsetA);
+
+    /* local read init pointers b */
+    localReadB = (__local DATA_TYPE *)(localMemory + localReadOffsetB);
+    MAC_4x4
+
+    /******************************************/
+    /* Unrolled Loop - End                    */
+    /******************************************/
+  }
+
+  /* prefetch: last unrolled iteration */
+  if (sizeL >= LOCAL_DEPTHU) {
+    barrier(CLK_LOCAL_MEM_FENCE);
+
+    /* iter 0 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 1 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 2 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 3 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+  }
+
+  /******************************************/
+  /* Tail Loop                              */
+  /******************************************/
+
+  /* local write reset offsets a */
+  localWriteOffsetA_0_0_0_0 %= LDS_OFFSET_BLK;
+
+  /* local write reset offsets b */
+  localWriteOffsetB_0_0_0_0 %= LDS_OFFSET_BLK;
+  numIterL = (((sizeL % LOCAL_DEPTHU) + LOCAL_SPLITU - 1) / LOCAL_SPLITU);
+
+  /* global read a */
+  a_0_0_0_0 = ( globalReadOffsetAL_0_0 + 0 >= (sizeL % LOCAL_DEPTHU) ) ? SCALAR_ZERO : *(globalReadA_0_0_0_0 + 0);
+
+  /* global read b */
+  b_0_0_0_0 = ( globalReadOffsetBL_0_0 + 0 >= (sizeL % LOCAL_DEPTHU) ) ? SCALAR_ZERO : *(globalReadB_0_0_0_0 + 0);
+  barrier(CLK_LOCAL_MEM_FENCE);
+
+  /* local write init pointers a */
+  localWriteA_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_0);
+
+  /* local write init pointers b */
+  localWriteB_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_0_0);
+
+  /* local write a */
+  *(localWriteA_0_0_0_0 + 0) = a_0_0_0_0;
+
+  /* local write b */
+  *(localWriteB_0_0_0_0 + 0) = b_0_0_0_0;
+  barrier(CLK_LOCAL_MEM_FENCE);
+
+  /* local read reset offsets a */
+  localReadOffsetA %= LDS_OFFSET_BLK;
+
+  /* local read reset offsets b */
+  localReadOffsetB %= LDS_OFFSET_BLK;
+
+  /* local read init pointers a */
+  localReadA = (__local DATA_TYPE *)(localMemory + localReadOffsetA);
+
+  /* local read init pointers b */
+  localReadB = (__local DATA_TYPE *)(localMemory + localReadOffsetB);
+
+  /* tail loop: macs */
+  while (numIterL-- > 0) {
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+  }
+
+  /* not-LocalSplitU: global write indices */
+  unsigned int globalC0I = (wg0I)*MT0I + (serial % SG0I)*VECTOR_WIDTH;
+  unsigned int globalC1J = (wg1J)*MT1J + (serial / SG0I)*VECTOR_WIDTH;
+  unsigned int globalCK = (wgK);
+
+  /* not-LocalSplitU: global write */
+  if (globalC0I + 0 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+0 + (0*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 1 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+1 + (0*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 0 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+0 + (0*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 1 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+1 + (0*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 0 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+0 + (0*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 1 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+1 + (0*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 0 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+0 + (0*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 1 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+1 + (0*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 0 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+0 + (1*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 1 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+1 + (1*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 0 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+0 + (1*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 1 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+1 + (1*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 0 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+0 + (1*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 1 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+1 + (1*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 0 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+0 + (1*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 1 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+1 + (1*VECTOR_WIDTH+1)*TT0I], beta) } }
+}
+);
+#endif
--- /dev/null
+++ b/src/library/blas/AutoGemm/UserGemmKernelSources/dgemm_NT_gfx906_tensile_src.cpp
@@ -0,0 +1,963 @@
+/*******************************************************************************
+ * Hand-tuned kernel
+ ******************************************************************************/
+
+#ifndef KERNEL_dgemm_NT_gfx906_TENSILE_SRC_H
+#define KERNEL_dgemm_NT_gfx906_TENSILE_SRC_H
+// #pragma message("AutoGemm's dgemm_NT_gfx906_tensile_src overriden by user.")
+
+const unsigned int dgemm_NT_gfx906_tensile_workGroupNumRows = 8;
+const unsigned int dgemm_NT_gfx906_tensile_workGroupNumCols = 16;
+const unsigned int dgemm_NT_gfx906_tensile_microTileNumRows = 4;
+const unsigned int dgemm_NT_gfx906_tensile_microTileNumCols = 4;
+
+#ifndef STRINGIFY
+#define STRINGIFY(S) STRINGIFY2(S)
+#define STRINGIFY2(S) #S
+#endif
+
+//if precompiled is enabled. All hand tuned kerenls should be precompiled.
+#ifndef AUTOGEMM_USE_PRE_COMPILED_KERNELS
+unsigned char *dgemm_NT_gfx906_tensile_bin = 0;
+size_t dgemm_NT_gfx906_tensile_binSize = 0;
+#endif
+
+const char * const dgemm_NT_gfx906_tensile_src = STRINGIFY(
+/******************************************/
+/* Function Prefix                        */
+/******************************************/
+
+/* tile parameters */
+#define NUM_THREADS 256
+#define SG0I 8
+#define SG1J 16
+#define TT0I 4
+#define TT1J 4
+#define MT0I (SG0I*TT0I)
+#define MT1J (SG1J*TT1J)
+#define VECTOR_WIDTH 2
+#define GLOBAL_LOAD_VECTOR_WIDTH_A 2
+#define GLOBAL_LOAD_VECTOR_WIDTH_B 2
+#define GLOBAL_WRITE_VECTOR_WIDTH 2
+
+/* DepthU parameters*/
+#define CPSV (NUM_THREADS / MT0I * VECTOR_WIDTH)
+#define LOCAL_SPLITU 2
+#define UNROLL 8
+#define LOCAL_DEPTHU (LOCAL_SPLITU*UNROLL)
+
+/* other */
+#define PAD 0
+#define WORK_GROUP_MAPPING 1
+
+/* num loads parallel and perpendicular to coalesced */
+#define NLCA 1
+#define NLCB 1
+#define NLPA 1
+#define NLPB 2
+
+/* load sizes parallel and perpendicular to coalesced */
+#define LSCA (MT0I/NLCA)
+#define LSPA (LOCAL_DEPTHU/NLPA)
+#define LSCB (MT1J/NLCB)
+#define LSPB (LOCAL_DEPTHU/NLPB)
+#define LVCA (LSCA/GLOBAL_LOAD_VECTOR_WIDTH_A)
+#define LVCB (LSCB/GLOBAL_LOAD_VECTOR_WIDTH_B)
+#define LVPA (LSPA/GLOBAL_LOAD_VECTOR_WIDTH_A)
+#define LVPB (LSPB/GLOBAL_LOAD_VECTOR_WIDTH_B)
+#define LDS_OFFSET_B 512
+#define LDS_NUM_ELEMENTS 4096
+#define LDS_OFFSET_BLK 2048
+
+/* global memory indices */
+#define GLOBAL_C(IDX0I, IDX1J, IDXK) (( (IDX0I)*strideC0I + (IDX1J)*strideC1J + (IDXK)*strideCK ))
+#define GLOBAL_OFFSET_A(IDX0I, IDXL, IDXK) (( (IDX0I)*strideA0I + (IDXL)*strideAL + (IDXK)*strideAK ))
+#define GLOBAL_OFFSET_B(IDX1J, IDXL, IDXK) (( (IDX1J)*strideB1J + (IDXL)*strideBL + (IDXK)*strideBK ))
+
+/* data types */
+#define DATA_TYPE double
+#define MAC(A,B,DST) mad(A,B,DST)
+
+/* MAC's */
+#define TYPE_MAC(MULA,MULB,DST) DST = MAC(MULA,MULB,DST);
+#define TYPE_MAC_WRITE(DST,ALPHA,REG,BETA) DST = 0 != (BETA) ? (ALPHA)*(REG) + (BETA)*(DST) : (ALPHA)*(REG);
+
+/* 4x4 micro-tile */
+#define MAC_4x4 \
+  TYPE_MAC(rA[0],rB[0],rC[0+0*TT0I]); \
+  TYPE_MAC(rA[1],rB[0],rC[1+0*TT0I]); \
+  TYPE_MAC(rA[2],rB[0],rC[2+0*TT0I]); \
+  TYPE_MAC(rA[3],rB[0],rC[3+0*TT0I]); \
+  TYPE_MAC(rA[0],rB[1],rC[0+1*TT0I]); \
+  TYPE_MAC(rA[1],rB[1],rC[1+1*TT0I]); \
+  TYPE_MAC(rA[2],rB[1],rC[2+1*TT0I]); \
+  TYPE_MAC(rA[3],rB[1],rC[3+1*TT0I]); \
+  TYPE_MAC(rA[0],rB[2],rC[0+2*TT0I]); \
+  TYPE_MAC(rA[1],rB[2],rC[1+2*TT0I]); \
+  TYPE_MAC(rA[2],rB[2],rC[2+2*TT0I]); \
+  TYPE_MAC(rA[3],rB[2],rC[3+2*TT0I]); \
+  TYPE_MAC(rA[0],rB[3],rC[0+3*TT0I]); \
+  TYPE_MAC(rA[1],rB[3],rC[1+3*TT0I]); \
+  TYPE_MAC(rA[2],rB[3],rC[2+3*TT0I]); \
+  TYPE_MAC(rA[3],rB[3],rC[3+3*TT0I]); \
+
+#define MAC_4x4_BLK \
+  TYPE_MAC(rA[0+TT0I],rB[0+TT1J],rC[0+0*TT0I]); \
+  TYPE_MAC(rA[1+TT0I],rB[0+TT1J],rC[1+0*TT0I]); \
+  TYPE_MAC(rA[2+TT0I],rB[0+TT1J],rC[2+0*TT0I]); \
+  TYPE_MAC(rA[3+TT0I],rB[0+TT1J],rC[3+0*TT0I]); \
+  TYPE_MAC(rA[0+TT0I],rB[1+TT1J],rC[0+1*TT0I]); \
+  TYPE_MAC(rA[1+TT0I],rB[1+TT1J],rC[1+1*TT0I]); \
+  TYPE_MAC(rA[2+TT0I],rB[1+TT1J],rC[2+1*TT0I]); \
+  TYPE_MAC(rA[3+TT0I],rB[1+TT1J],rC[3+1*TT0I]); \
+  TYPE_MAC(rA[0+TT0I],rB[2+TT1J],rC[0+2*TT0I]); \
+  TYPE_MAC(rA[1+TT0I],rB[2+TT1J],rC[1+2*TT0I]); \
+  TYPE_MAC(rA[2+TT0I],rB[2+TT1J],rC[2+2*TT0I]); \
+  TYPE_MAC(rA[3+TT0I],rB[2+TT1J],rC[3+2*TT0I]); \
+  TYPE_MAC(rA[0+TT0I],rB[3+TT1J],rC[0+3*TT0I]); \
+  TYPE_MAC(rA[1+TT0I],rB[3+TT1J],rC[1+3*TT0I]); \
+  TYPE_MAC(rA[2+TT0I],rB[3+TT1J],rC[2+3*TT0I]); \
+  TYPE_MAC(rA[3+TT0I],rB[3+TT1J],rC[3+3*TT0I]); \
+
+/* hard-coded initial strides */
+__constant unsigned int strideC0I = 1;
+__constant unsigned int strideA0I = 1;
+__constant unsigned int strideB1J = 1;
+
+  /******************************************/
+  /* Begin Kernel                           */
+  /******************************************/
+__attribute__((reqd_work_group_size(NUM_THREADS,1,1)))
+__kernel void Cijk_Ailk_Bjlk_DB_MT032x064x16_K1_PGR1_PLR1_TT04_04_WG08_16_02_WGM01(
+  __global double *C,
+  __global double const * restrict A,
+  __global double const * restrict B,
+  double const alpha,
+  double const beta,
+  unsigned int const offsetC,
+  unsigned int const offsetA,
+  unsigned int const offsetB,
+  unsigned int const strideC1J,
+  unsigned int const strideCK,
+  unsigned int const strideAL,
+  unsigned int const strideAK,
+  unsigned int const strideBL,
+  unsigned int const strideBK,
+  unsigned int const size0I,
+  unsigned int const size1J,
+  unsigned int const sizeK,
+  unsigned int const sizeL ) {
+
+  /******************************************/
+  /* Allocate Resources                     */
+  /******************************************/
+#define SCALAR_ZERO (double)(0)
+  DATA_TYPE rA[TT0I*2];
+  DATA_TYPE rB[TT1J*2];
+
+  /* registers for global->local */
+  DATA_TYPE a_0_0_0_0;
+  DATA_TYPE a_0_1_0_0;
+  DATA_TYPE b_0_0_0_0;
+  DATA_TYPE b_0_1_0_0;
+  DATA_TYPE b_0_0_1_0;
+  DATA_TYPE b_0_1_1_0;
+
+  /* allocate local memory */
+  __local DATA_TYPE localMemory[LDS_NUM_ELEMENTS];
+
+  /******************************************/
+  /* Global Read Addresses                  */
+  /******************************************/
+
+  /* global read addresses: subgroup */
+  unsigned int serial = get_local_id(0);
+  unsigned int sgId = serial / (SG0I*SG1J);
+
+  /* global read addresses: work-group */
+  unsigned int wg0I = get_group_id(0);
+  unsigned int wg1J = get_group_id(1);
+  unsigned int nwg0I = get_num_groups(0);
+  unsigned int nwg1J = get_num_groups(1);
+
+  /* global read addresses: tile offset assignment a */
+  unsigned int globalReadOffsetA0I = (serial%LVCA)*GLOBAL_LOAD_VECTOR_WIDTH_A + (wg0I)*MT0I;
+
+  /* global read addresses: tile offset assignment b */
+  unsigned int globalReadOffsetB1J = (serial%LVCB)*GLOBAL_LOAD_VECTOR_WIDTH_B + (wg1J)*MT1J;
+
+  /* global read addresses: unroll assignment a */
+  unsigned int globalReadOffsetAL = (serial/LVCA);
+
+  /* global read addresses: unroll assignment b */
+  unsigned int globalReadOffsetBL = (serial/LVCB);
+
+  /* global read addresses: other free assignments */
+  unsigned int wgK = ( get_group_id(2) ) % sizeK;
+
+  /* global read addresses: tile offsets a */
+  unsigned int globalReadOffsetA0I_0_0 = globalReadOffsetA0I + 0 + 0*LSCA;
+
+  /* global read addresses: tile offsets b */
+  unsigned int globalReadOffsetB1J_0_0 = globalReadOffsetB1J + 0 + 0*LSCB;
+
+  /* global read addresses: unroll offsets a */
+  unsigned int globalReadOffsetAL_0_0 = globalReadOffsetAL + 0 + 0*LSPA;
+
+  /* global read addresses: unroll offsets b */
+  unsigned int globalReadOffsetBL_0_0 = globalReadOffsetBL + 0 + 0*LSPB;
+  unsigned int globalReadOffsetBL_1_0 = globalReadOffsetBL + 0 + 1*LSPB;
+
+  /* global read addresses: shift a */
+  globalReadOffsetA0I_0_0 = (  globalReadOffsetA0I_0_0 > size0I-GLOBAL_LOAD_VECTOR_WIDTH_A+0) ? size0I-GLOBAL_LOAD_VECTOR_WIDTH_A+0 : globalReadOffsetA0I_0_0;
+
+  /* global read addresses: shift b */
+  globalReadOffsetB1J_0_0 = (  globalReadOffsetB1J_0_0 > size1J-GLOBAL_LOAD_VECTOR_WIDTH_B+0) ? size1J-GLOBAL_LOAD_VECTOR_WIDTH_B+0 : globalReadOffsetB1J_0_0;
+
+  /* global read addresses: final offsets a */
+  unsigned long globalReadOffsetA_0_0_0_0 = GLOBAL_OFFSET_A( globalReadOffsetA0I_0_0, globalReadOffsetAL_0_0, wgK );
+
+  /* global read addresses: final offsets b */
+  unsigned long globalReadOffsetB_0_0_0_0 = GLOBAL_OFFSET_B( globalReadOffsetB1J_0_0, globalReadOffsetBL_0_0, wgK );
+  unsigned long globalReadOffsetB_0_0_1_0 = GLOBAL_OFFSET_B( globalReadOffsetB1J_0_0, globalReadOffsetBL_1_0, wgK );
+
+  /* global read addresses: apply user offsets */
+  C += offsetC;
+  A += offsetA;
+  B += offsetB;
+
+  /* global read addresses: addresses a */
+  __global DATA_TYPE const *globalReadA_0_0_0_0 = A + globalReadOffsetA_0_0_0_0;
+
+  /* global read addresses: addresses b */
+  __global DATA_TYPE const *globalReadB_0_0_0_0 = B + globalReadOffsetB_0_0_0_0;
+  __global DATA_TYPE const *globalReadB_0_0_1_0 = B + globalReadOffsetB_0_0_1_0;
+
+  /* global read addresses: increments a */
+  long globalReadIncAL = (long)strideAL*LOCAL_DEPTHU;
+
+  /* global read addresses: increments b */
+  long globalReadIncBL = (long)strideBL*LOCAL_DEPTHU;
+
+  /******************************************/
+  /* Local Write Addresses                  */
+  /******************************************/
+
+  /* local write addresses: tile assignment a */
+  unsigned int lwA0I = (serial%LVCA)*GLOBAL_LOAD_VECTOR_WIDTH_A;
+
+  /* local write addresses: tile assignment b */
+  unsigned int lwB1J = (serial%LVCB)*GLOBAL_LOAD_VECTOR_WIDTH_B;
+
+  /* local write addresses: unroll assignment a */
+  unsigned int lwAL = (serial/LVCA);
+
+  /* local write addresses: unroll assignment b */
+  unsigned int lwBL = (serial/LVCB);
+
+  /* local write addresses: first offset a */
+  unsigned int localWriteFirstOffsetA = lwA0I + lwAL*(MT0I+PAD);
+
+  /* local write addresses: first offset b */
+  unsigned int localWriteFirstOffsetB = lwB1J + lwBL*(MT1J+PAD) + LDS_OFFSET_B;
+
+  /* local write addresses: final offsets a */
+  unsigned int localWriteOffsetA_0_0_0_0 = localWriteFirstOffsetA + (0 + 0*LSCA) + (0 + 0*LSPA)*(MT0I+PAD);
+
+  /* local write addresses: final offsets b */
+  unsigned int localWriteOffsetB_0_0_0_0 = localWriteFirstOffsetB + (0 + 0*LSCB) + (0 + 0*LSPB)*(MT1J+PAD);
+  unsigned int localWriteOffsetB_0_0_1_0 = localWriteFirstOffsetB + (0 + 0*LSCB) + (0 + 1*LSPB)*(MT1J+PAD);
+
+  /* local write addresses: declare addresses a */
+  __local DATA_TYPE *localWriteA_0_0_0_0;
+
+  /* local write addresses: declare addresses b */
+  __local DATA_TYPE *localWriteB_0_0_0_0;
+  __local DATA_TYPE *localWriteB_0_0_1_0;
+
+  /* local write addresses: init pointers a */
+  localWriteA_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_0);
+
+  /* local write addresses: init pointers b */
+  localWriteB_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_0_0);
+  localWriteB_0_0_1_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_1_0);
+
+  /******************************************/
+  /* Local Read Addresses                   */
+  /******************************************/
+
+  /* local read addresses: tile assignments a */
+  unsigned int lr0I = (serial % SG0I);
+
+  /* local read addresses: tile assignments b */
+  unsigned int lr1J = (serial / SG0I) % SG1J;
+
+  /* local read addresses: final offsets a */
+  unsigned int localReadOffsetA = lr0I*VECTOR_WIDTH + sgId*(MT0I+PAD);
+
+  /* local read addresses: final offsets b */
+  unsigned int localReadOffsetB = lr1J*VECTOR_WIDTH + sgId*(MT1J+PAD) + LDS_OFFSET_B;
+
+  /* local read addresses: declare addresses a */
+  __local DATA_TYPE *localReadA;
+
+  /* local read addresses: declare addresses b */
+  __local DATA_TYPE *localReadB;
+
+  /* declare loop num iterations */
+  unsigned int numIterL;
+
+  /* registers for MAC's */
+  DATA_TYPE rC[TT0I*TT1J];
+  rC[0] = SCALAR_ZERO;
+  rC[1] = SCALAR_ZERO;
+  rC[2] = SCALAR_ZERO;
+  rC[3] = SCALAR_ZERO;
+  rC[4] = SCALAR_ZERO;
+  rC[5] = SCALAR_ZERO;
+  rC[6] = SCALAR_ZERO;
+  rC[7] = SCALAR_ZERO;
+  rC[8] = SCALAR_ZERO;
+  rC[9] = SCALAR_ZERO;
+  rC[10] = SCALAR_ZERO;
+  rC[11] = SCALAR_ZERO;
+  rC[12] = SCALAR_ZERO;
+  rC[13] = SCALAR_ZERO;
+  rC[14] = SCALAR_ZERO;
+  rC[15] = SCALAR_ZERO;
+  numIterL = sizeL / LOCAL_DEPTHU;
+
+  /* local read addresses: init pointers a */
+  localReadA = (__local DATA_TYPE *)(localMemory + localReadOffsetA);
+
+  /* local read addresses: init pointers b */
+  localReadB = (__local DATA_TYPE *)(localMemory + localReadOffsetB);
+
+  /* prefetch: global -> local */
+  if (sizeL >= LOCAL_DEPTHU) {
+
+    /* global read a */
+    a_0_0_0_0 = *(globalReadA_0_0_0_0 + 0);
+    a_0_1_0_0 = *(globalReadA_0_0_0_0 + 1);
+
+    /* global read b */
+    b_0_0_0_0 = *(globalReadB_0_0_0_0 + 0);
+    b_0_1_0_0 = *(globalReadB_0_0_0_0 + 1);
+    b_0_0_1_0 = *(globalReadB_0_0_1_0 + 0);
+    b_0_1_1_0 = *(globalReadB_0_0_1_0 + 1);
+
+    /* global read inc a */
+    globalReadA_0_0_0_0 = (__global DATA_TYPE const *)( ((__global DATA_TYPE const *)globalReadA_0_0_0_0) + globalReadIncAL);
+
+    /* global read inc b */
+    globalReadB_0_0_0_0 = (__global DATA_TYPE const *)( ((__global DATA_TYPE const *)globalReadB_0_0_0_0) + globalReadIncBL);
+    globalReadB_0_0_1_0 = (__global DATA_TYPE const *)( ((__global DATA_TYPE const *)globalReadB_0_0_1_0) + globalReadIncBL);
+
+    /* local write a */
+    *(localWriteA_0_0_0_0 + 0) = a_0_0_0_0;
+    *(localWriteA_0_0_0_0 + 1) = a_0_1_0_0;
+
+    /* local write b */
+    *(localWriteB_0_0_0_0 + 0) = b_0_0_0_0;
+    *(localWriteB_0_0_0_0 + 1) = b_0_1_0_0;
+    *(localWriteB_0_0_1_0 + 0) = b_0_0_1_0;
+    *(localWriteB_0_0_1_0 + 1) = b_0_1_1_0;
+
+    /* local write swap a */
+    localWriteOffsetA_0_0_0_0 = (localWriteOffsetA_0_0_0_0 + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+
+    /* local write swap b */
+    localWriteOffsetB_0_0_0_0 = (localWriteOffsetB_0_0_0_0 + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+    localWriteOffsetB_0_0_1_0 = (localWriteOffsetB_0_0_1_0 + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+
+    /* local write init pointers a */
+    localWriteA_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_0);
+
+    /* local write init pointers b */
+    localWriteB_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_0_0);
+    localWriteB_0_0_1_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_1_0);
+    barrier(CLK_LOCAL_MEM_FENCE);
+
+    /* local read prefetch a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read prefetch b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+  }
+
+  /******************************************/
+  /* Unrolled Loop - Begin                  */
+  /******************************************/
+  while (numIterL-- > 1) {
+
+    /* global read a */
+    a_0_0_0_0 = *(globalReadA_0_0_0_0 + 0);
+    a_0_1_0_0 = *(globalReadA_0_0_0_0 + 1);
+
+    /* global read b */
+    b_0_0_0_0 = *(globalReadB_0_0_0_0 + 0);
+    b_0_1_0_0 = *(globalReadB_0_0_0_0 + 1);
+    b_0_0_1_0 = *(globalReadB_0_0_1_0 + 0);
+    b_0_1_1_0 = *(globalReadB_0_0_1_0 + 1);
+
+    /* global read inc a */
+    globalReadA_0_0_0_0 = (__global DATA_TYPE const *)( ((__global DATA_TYPE const *)globalReadA_0_0_0_0) + globalReadIncAL);
+
+    /* global read inc b */
+    globalReadB_0_0_0_0 = (__global DATA_TYPE const *)( ((__global DATA_TYPE const *)globalReadB_0_0_0_0) + globalReadIncBL);
+    globalReadB_0_0_1_0 = (__global DATA_TYPE const *)( ((__global DATA_TYPE const *)globalReadB_0_0_1_0) + globalReadIncBL);
+
+    /* iter 0 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0+TT0I] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1+TT0I] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0+TT0I] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1+TT0I] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0+TT1J] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1+TT1J] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0+TT1J] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1+TT1J] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 1 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4_BLK
+
+    /* iter 2 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0+TT0I] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1+TT0I] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0+TT0I] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1+TT0I] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0+TT1J] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1+TT1J] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0+TT1J] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1+TT1J] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 3 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4_BLK
+
+    /* iter 4 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0+TT0I] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1+TT0I] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0+TT0I] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1+TT0I] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0+TT1J] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1+TT1J] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0+TT1J] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1+TT1J] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 5 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4_BLK
+
+    /* iter 6 (swap local pointers iteration) */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0+TT0I] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1+TT0I] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0+TT0I] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1+TT0I] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0+TT1J] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1+TT1J] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0+TT1J] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1+TT1J] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local write a */
+    *(localWriteA_0_0_0_0 + 0) = a_0_0_0_0;
+    *(localWriteA_0_0_0_0 + 1) = a_0_1_0_0;
+
+    /* local write b */
+    *(localWriteB_0_0_0_0 + 0) = b_0_0_0_0;
+    *(localWriteB_0_0_0_0 + 1) = b_0_1_0_0;
+    *(localWriteB_0_0_1_0 + 0) = b_0_0_1_0;
+    *(localWriteB_0_0_1_0 + 1) = b_0_1_1_0;
+
+    /* local write swap offsets a */
+    localWriteOffsetA_0_0_0_0 = (localWriteOffsetA_0_0_0_0 + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+
+    /* local write swap offsets b */
+    localWriteOffsetB_0_0_0_0 = (localWriteOffsetB_0_0_0_0 + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+    localWriteOffsetB_0_0_1_0 = (localWriteOffsetB_0_0_1_0 + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+
+    /* local write init pointers a */
+    localWriteA_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_0);
+
+    /* local write init pointers b */
+    localWriteB_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_0_0);
+    localWriteB_0_0_1_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_1_0);
+
+    /* local read swap offsets a */
+    localReadOffsetA = (localReadOffsetA + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+
+    /* local read swap offsets b */
+    localReadOffsetB = (localReadOffsetB + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+
+    /* local read init pointers a */
+    localReadA = (__local DATA_TYPE *)(localMemory + localReadOffsetA);
+
+    /* local read init pointers b */
+    localReadB = (__local DATA_TYPE *)(localMemory + localReadOffsetB);
+    MAC_4x4
+
+    /* iter 7 (last) */
+    barrier(CLK_LOCAL_MEM_FENCE);
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4_BLK
+
+    /******************************************/
+    /* Unrolled Loop - End                    */
+    /******************************************/
+  }
+
+  /* prefetch: last unrolled iteration */
+  if (sizeL >= LOCAL_DEPTHU) {
+
+    /* iter 0 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0+TT0I] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1+TT0I] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0+TT0I] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1+TT0I] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0+TT1J] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1+TT1J] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0+TT1J] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1+TT1J] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 1 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4_BLK
+
+    /* iter 2 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0+TT0I] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1+TT0I] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0+TT0I] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1+TT0I] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0+TT1J] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1+TT1J] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0+TT1J] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1+TT1J] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 3 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4_BLK
+
+    /* iter 4 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0+TT0I] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1+TT0I] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0+TT0I] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1+TT0I] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0+TT1J] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1+TT1J] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0+TT1J] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1+TT1J] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 5 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4_BLK
+
+    /* iter 6 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0+TT0I] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1+TT0I] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0+TT0I] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1+TT0I] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0+TT1J] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1+TT1J] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0+TT1J] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1+TT1J] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 7 */
+    MAC_4x4_BLK
+  }
+
+  /******************************************/
+  /* Tail Loop                              */
+  /******************************************/
+
+  /* local write reset offsets a */
+  localWriteOffsetA_0_0_0_0 %= LDS_OFFSET_BLK;
+
+  /* local write reset offsets b */
+  localWriteOffsetB_0_0_0_0 %= LDS_OFFSET_BLK;
+  localWriteOffsetB_0_0_1_0 %= LDS_OFFSET_BLK;
+  numIterL = (((sizeL % LOCAL_DEPTHU) + LOCAL_SPLITU - 1) / LOCAL_SPLITU);
+
+  /* global read a */
+  a_0_0_0_0 = ( globalReadOffsetAL_0_0 + 0 >= (sizeL % LOCAL_DEPTHU) ) ? SCALAR_ZERO : *(globalReadA_0_0_0_0 + 0);
+  a_0_1_0_0 = ( globalReadOffsetAL_0_0 + 0 >= (sizeL % LOCAL_DEPTHU) ) ? SCALAR_ZERO : *(globalReadA_0_0_0_0 + 1);
+
+  /* global read b */
+  b_0_0_0_0 = ( globalReadOffsetBL_0_0 + 0 >= (sizeL % LOCAL_DEPTHU) ) ? SCALAR_ZERO : *(globalReadB_0_0_0_0 + 0);
+  b_0_1_0_0 = ( globalReadOffsetBL_0_0 + 0 >= (sizeL % LOCAL_DEPTHU) ) ? SCALAR_ZERO : *(globalReadB_0_0_0_0 + 1);
+  b_0_0_1_0 = ( globalReadOffsetBL_1_0 + 0 >= (sizeL % LOCAL_DEPTHU) ) ? SCALAR_ZERO : *(globalReadB_0_0_1_0 + 0);
+  b_0_1_1_0 = ( globalReadOffsetBL_1_0 + 0 >= (sizeL % LOCAL_DEPTHU) ) ? SCALAR_ZERO : *(globalReadB_0_0_1_0 + 1);
+  barrier(CLK_LOCAL_MEM_FENCE);
+
+  /* local write init pointers a */
+  localWriteA_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_0);
+
+  /* local write init pointers b */
+  localWriteB_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_0_0);
+  localWriteB_0_0_1_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_1_0);
+
+  /* local write a */
+  *(localWriteA_0_0_0_0 + 0) = a_0_0_0_0;
+  *(localWriteA_0_0_0_0 + 1) = a_0_1_0_0;
+
+  /* local write b */
+  *(localWriteB_0_0_0_0 + 0) = b_0_0_0_0;
+  *(localWriteB_0_0_0_0 + 1) = b_0_1_0_0;
+  *(localWriteB_0_0_1_0 + 0) = b_0_0_1_0;
+  *(localWriteB_0_0_1_0 + 1) = b_0_1_1_0;
+  barrier(CLK_LOCAL_MEM_FENCE);
+
+  /* local read reset offsets a */
+  localReadOffsetA %= LDS_OFFSET_BLK;
+
+  /* local read reset offsets b */
+  localReadOffsetB %= LDS_OFFSET_BLK;
+
+  /* local read init pointers a */
+  localReadA = (__local DATA_TYPE *)(localMemory + localReadOffsetA);
+
+  /* local read init pointers b */
+  localReadB = (__local DATA_TYPE *)(localMemory + localReadOffsetB);
+
+  /* tail loop: macs */
+  while (numIterL-- > 0) {
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+  }
+
+  /* shift vector components d0 */
+  unsigned int wgMT0I = size0I - wg0I*MT0I;
+  if (wgMT0I > MT0I) wgMT0I = MT0I;
+  unsigned int r0I = wgMT0I % GLOBAL_LOAD_VECTOR_WIDTH_A;
+  if (r0I > 0 && ((wgMT0I/VECTOR_WIDTH) % SG0I) == (serial % SG0I) ) {
+    unsigned int s0I = (wgMT0I%VECTOR_WIDTH)/GLOBAL_LOAD_VECTOR_WIDTH_A + (wgMT0I/(SG0I*VECTOR_WIDTH))*(VECTOR_WIDTH/GLOBAL_LOAD_VECTOR_WIDTH_A);
+    if (r0I == 1) {
+      if (s0I == 0) {
+        rC[0 + 0*GLOBAL_LOAD_VECTOR_WIDTH_A + 0*TT0I] = rC[1 + 0*GLOBAL_LOAD_VECTOR_WIDTH_A + 0*TT0I];
+        rC[0 + 0*GLOBAL_LOAD_VECTOR_WIDTH_A + 1*TT0I] = rC[1 + 0*GLOBAL_LOAD_VECTOR_WIDTH_A + 1*TT0I];
+        rC[0 + 0*GLOBAL_LOAD_VECTOR_WIDTH_A + 2*TT0I] = rC[1 + 0*GLOBAL_LOAD_VECTOR_WIDTH_A + 2*TT0I];
+        rC[0 + 0*GLOBAL_LOAD_VECTOR_WIDTH_A + 3*TT0I] = rC[1 + 0*GLOBAL_LOAD_VECTOR_WIDTH_A + 3*TT0I];
+      } else {
+        rC[0 + 1*GLOBAL_LOAD_VECTOR_WIDTH_A + 0*TT0I] = rC[1 + 1*GLOBAL_LOAD_VECTOR_WIDTH_A + 0*TT0I];
+        rC[0 + 1*GLOBAL_LOAD_VECTOR_WIDTH_A + 1*TT0I] = rC[1 + 1*GLOBAL_LOAD_VECTOR_WIDTH_A + 1*TT0I];
+        rC[0 + 1*GLOBAL_LOAD_VECTOR_WIDTH_A + 2*TT0I] = rC[1 + 1*GLOBAL_LOAD_VECTOR_WIDTH_A + 2*TT0I];
+        rC[0 + 1*GLOBAL_LOAD_VECTOR_WIDTH_A + 3*TT0I] = rC[1 + 1*GLOBAL_LOAD_VECTOR_WIDTH_A + 3*TT0I];
+      }
+    }
+  }
+
+  /* shift vector components d1 */
+  unsigned int wgMT1J = size1J - wg1J*MT1J;
+  if (wgMT1J > MT1J) wgMT1J = MT1J;
+  unsigned int r1J = wgMT1J % GLOBAL_LOAD_VECTOR_WIDTH_B;
+  if (r1J > 0 && ((wgMT1J/VECTOR_WIDTH) % SG1J) == (serial / SG0I) % SG1J ) {
+    unsigned int s1J = (wgMT1J%VECTOR_WIDTH)/GLOBAL_LOAD_VECTOR_WIDTH_B + (wgMT1J/(SG1J*VECTOR_WIDTH))*(VECTOR_WIDTH/GLOBAL_LOAD_VECTOR_WIDTH_B);
+    if (r1J == 1) {
+      if (s1J == 0) {
+        rC[0 + 0*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[0 + 0*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+        rC[1 + 0*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[1 + 0*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+        rC[2 + 0*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[2 + 0*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+        rC[3 + 0*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[3 + 0*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+      } else {
+        rC[0 + 1*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[0 + 1*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+        rC[1 + 1*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[1 + 1*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+        rC[2 + 1*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[2 + 1*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+        rC[3 + 1*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[3 + 1*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+      }
+    }
+  }
+
+  /******************************************/
+  /* LocalSplitU Reduction                  */
+  /******************************************/
+  barrier(CLK_LOCAL_MEM_FENCE);
+
+  /* LocalSplitU: local write */
+  __local DATA_TYPE *localLocalSplitU = (__local DATA_TYPE *)(localMemory);
+  localLocalSplitU[0 + (lr0I + 0*SG0I + (MT0I/VECTOR_WIDTH)*(lr1J*VECTOR_WIDTH + 0 + SG1J*VECTOR_WIDTH*0) + (MT0I*MT1J/VECTOR_WIDTH)*sgId)*VECTOR_WIDTH] = rC[0 + (0+0*(TT0I/VECTOR_WIDTH)+0*TT0I)*VECTOR_WIDTH];
+  localLocalSplitU[1 + (lr0I + 0*SG0I + (MT0I/VECTOR_WIDTH)*(lr1J*VECTOR_WIDTH + 0 + SG1J*VECTOR_WIDTH*0) + (MT0I*MT1J/VECTOR_WIDTH)*sgId)*VECTOR_WIDTH] = rC[1 + (0+0*(TT0I/VECTOR_WIDTH)+0*TT0I)*VECTOR_WIDTH];
+  localLocalSplitU[0 + (lr0I + 0*SG0I + (MT0I/VECTOR_WIDTH)*(lr1J*VECTOR_WIDTH + 1 + SG1J*VECTOR_WIDTH*0) + (MT0I*MT1J/VECTOR_WIDTH)*sgId)*VECTOR_WIDTH] = rC[0 + (0+1*(TT0I/VECTOR_WIDTH)+0*TT0I)*VECTOR_WIDTH];
+  localLocalSplitU[1 + (lr0I + 0*SG0I + (MT0I/VECTOR_WIDTH)*(lr1J*VECTOR_WIDTH + 1 + SG1J*VECTOR_WIDTH*0) + (MT0I*MT1J/VECTOR_WIDTH)*sgId)*VECTOR_WIDTH] = rC[1 + (0+1*(TT0I/VECTOR_WIDTH)+0*TT0I)*VECTOR_WIDTH];
+  localLocalSplitU[0 + (lr0I + 1*SG0I + (MT0I/VECTOR_WIDTH)*(lr1J*VECTOR_WIDTH + 0 + SG1J*VECTOR_WIDTH*0) + (MT0I*MT1J/VECTOR_WIDTH)*sgId)*VECTOR_WIDTH] = rC[0 + (1+0*(TT0I/VECTOR_WIDTH)+0*TT0I)*VECTOR_WIDTH];
+  localLocalSplitU[1 + (lr0I + 1*SG0I + (MT0I/VECTOR_WIDTH)*(lr1J*VECTOR_WIDTH + 0 + SG1J*VECTOR_WIDTH*0) + (MT0I*MT1J/VECTOR_WIDTH)*sgId)*VECTOR_WIDTH] = rC[1 + (1+0*(TT0I/VECTOR_WIDTH)+0*TT0I)*VECTOR_WIDTH];
+  localLocalSplitU[0 + (lr0I + 1*SG0I + (MT0I/VECTOR_WIDTH)*(lr1J*VECTOR_WIDTH + 1 + SG1J*VECTOR_WIDTH*0) + (MT0I*MT1J/VECTOR_WIDTH)*sgId)*VECTOR_WIDTH] = rC[0 + (1+1*(TT0I/VECTOR_WIDTH)+0*TT0I)*VECTOR_WIDTH];
+  localLocalSplitU[1 + (lr0I + 1*SG0I + (MT0I/VECTOR_WIDTH)*(lr1J*VECTOR_WIDTH + 1 + SG1J*VECTOR_WIDTH*0) + (MT0I*MT1J/VECTOR_WIDTH)*sgId)*VECTOR_WIDTH] = rC[1 + (1+1*(TT0I/VECTOR_WIDTH)+0*TT0I)*VECTOR_WIDTH];
+  localLocalSplitU[0 + (lr0I + 0*SG0I + (MT0I/VECTOR_WIDTH)*(lr1J*VECTOR_WIDTH + 0 + SG1J*VECTOR_WIDTH*1) + (MT0I*MT1J/VECTOR_WIDTH)*sgId)*VECTOR_WIDTH] = rC[0 + (0+0*(TT0I/VECTOR_WIDTH)+1*TT0I)*VECTOR_WIDTH];
+  localLocalSplitU[1 + (lr0I + 0*SG0I + (MT0I/VECTOR_WIDTH)*(lr1J*VECTOR_WIDTH + 0 + SG1J*VECTOR_WIDTH*1) + (MT0I*MT1J/VECTOR_WIDTH)*sgId)*VECTOR_WIDTH] = rC[1 + (0+0*(TT0I/VECTOR_WIDTH)+1*TT0I)*VECTOR_WIDTH];
+  localLocalSplitU[0 + (lr0I + 0*SG0I + (MT0I/VECTOR_WIDTH)*(lr1J*VECTOR_WIDTH + 1 + SG1J*VECTOR_WIDTH*1) + (MT0I*MT1J/VECTOR_WIDTH)*sgId)*VECTOR_WIDTH] = rC[0 + (0+1*(TT0I/VECTOR_WIDTH)+1*TT0I)*VECTOR_WIDTH];
+  localLocalSplitU[1 + (lr0I + 0*SG0I + (MT0I/VECTOR_WIDTH)*(lr1J*VECTOR_WIDTH + 1 + SG1J*VECTOR_WIDTH*1) + (MT0I*MT1J/VECTOR_WIDTH)*sgId)*VECTOR_WIDTH] = rC[1 + (0+1*(TT0I/VECTOR_WIDTH)+1*TT0I)*VECTOR_WIDTH];
+  localLocalSplitU[0 + (lr0I + 1*SG0I + (MT0I/VECTOR_WIDTH)*(lr1J*VECTOR_WIDTH + 0 + SG1J*VECTOR_WIDTH*1) + (MT0I*MT1J/VECTOR_WIDTH)*sgId)*VECTOR_WIDTH] = rC[0 + (1+0*(TT0I/VECTOR_WIDTH)+1*TT0I)*VECTOR_WIDTH];
+  localLocalSplitU[1 + (lr0I + 1*SG0I + (MT0I/VECTOR_WIDTH)*(lr1J*VECTOR_WIDTH + 0 + SG1J*VECTOR_WIDTH*1) + (MT0I*MT1J/VECTOR_WIDTH)*sgId)*VECTOR_WIDTH] = rC[1 + (1+0*(TT0I/VECTOR_WIDTH)+1*TT0I)*VECTOR_WIDTH];
+  localLocalSplitU[0 + (lr0I + 1*SG0I + (MT0I/VECTOR_WIDTH)*(lr1J*VECTOR_WIDTH + 1 + SG1J*VECTOR_WIDTH*1) + (MT0I*MT1J/VECTOR_WIDTH)*sgId)*VECTOR_WIDTH] = rC[0 + (1+1*(TT0I/VECTOR_WIDTH)+1*TT0I)*VECTOR_WIDTH];
+  localLocalSplitU[1 + (lr0I + 1*SG0I + (MT0I/VECTOR_WIDTH)*(lr1J*VECTOR_WIDTH + 1 + SG1J*VECTOR_WIDTH*1) + (MT0I*MT1J/VECTOR_WIDTH)*sgId)*VECTOR_WIDTH] = rC[1 + (1+1*(TT0I/VECTOR_WIDTH)+1*TT0I)*VECTOR_WIDTH];
+  barrier(CLK_LOCAL_MEM_FENCE);
+
+  /* LocalSplitU: local read */
+  rC[0 +   0*GLOBAL_WRITE_VECTOR_WIDTH] = localLocalSplitU[0 + (serial+0*NUM_THREADS)*GLOBAL_WRITE_VECTOR_WIDTH];
+  rC[1 +   0*GLOBAL_WRITE_VECTOR_WIDTH] = localLocalSplitU[1 + (serial+0*NUM_THREADS)*GLOBAL_WRITE_VECTOR_WIDTH];
+  rC[0 +   1*GLOBAL_WRITE_VECTOR_WIDTH] = localLocalSplitU[0 + (serial+1*NUM_THREADS)*GLOBAL_WRITE_VECTOR_WIDTH];
+  rC[1 +   1*GLOBAL_WRITE_VECTOR_WIDTH] = localLocalSplitU[1 + (serial+1*NUM_THREADS)*GLOBAL_WRITE_VECTOR_WIDTH];
+  rC[0 +   2*GLOBAL_WRITE_VECTOR_WIDTH] = localLocalSplitU[0 + (serial+2*NUM_THREADS)*GLOBAL_WRITE_VECTOR_WIDTH];
+  rC[1 +   2*GLOBAL_WRITE_VECTOR_WIDTH] = localLocalSplitU[1 + (serial+2*NUM_THREADS)*GLOBAL_WRITE_VECTOR_WIDTH];
+  rC[0 +   3*GLOBAL_WRITE_VECTOR_WIDTH] = localLocalSplitU[0 + (serial+3*NUM_THREADS)*GLOBAL_WRITE_VECTOR_WIDTH];
+  rC[1 +   3*GLOBAL_WRITE_VECTOR_WIDTH] = localLocalSplitU[1 + (serial+3*NUM_THREADS)*GLOBAL_WRITE_VECTOR_WIDTH];
+
+
+  /* LocalSplitU: reduction */
+  rC[0 +   0*GLOBAL_WRITE_VECTOR_WIDTH] += localLocalSplitU[(0 + serial*GLOBAL_WRITE_VECTOR_WIDTH+0*NUM_THREADS*GLOBAL_WRITE_VECTOR_WIDTH + 1*MT0I*MT1J)];
+  rC[1 +   0*GLOBAL_WRITE_VECTOR_WIDTH] += localLocalSplitU[(1 + serial*GLOBAL_WRITE_VECTOR_WIDTH+0*NUM_THREADS*GLOBAL_WRITE_VECTOR_WIDTH + 1*MT0I*MT1J)];
+  rC[0 +   1*GLOBAL_WRITE_VECTOR_WIDTH] += localLocalSplitU[(0 + serial*GLOBAL_WRITE_VECTOR_WIDTH+1*NUM_THREADS*GLOBAL_WRITE_VECTOR_WIDTH + 1*MT0I*MT1J)];
+  rC[1 +   1*GLOBAL_WRITE_VECTOR_WIDTH] += localLocalSplitU[(1 + serial*GLOBAL_WRITE_VECTOR_WIDTH+1*NUM_THREADS*GLOBAL_WRITE_VECTOR_WIDTH + 1*MT0I*MT1J)];
+  rC[0 +   2*GLOBAL_WRITE_VECTOR_WIDTH] += localLocalSplitU[(0 + serial*GLOBAL_WRITE_VECTOR_WIDTH+2*NUM_THREADS*GLOBAL_WRITE_VECTOR_WIDTH + 1*MT0I*MT1J)];
+  rC[1 +   2*GLOBAL_WRITE_VECTOR_WIDTH] += localLocalSplitU[(1 + serial*GLOBAL_WRITE_VECTOR_WIDTH+2*NUM_THREADS*GLOBAL_WRITE_VECTOR_WIDTH + 1*MT0I*MT1J)];
+  rC[0 +   3*GLOBAL_WRITE_VECTOR_WIDTH] += localLocalSplitU[(0 + serial*GLOBAL_WRITE_VECTOR_WIDTH+3*NUM_THREADS*GLOBAL_WRITE_VECTOR_WIDTH + 1*MT0I*MT1J)];
+  rC[1 +   3*GLOBAL_WRITE_VECTOR_WIDTH] += localLocalSplitU[(1 + serial*GLOBAL_WRITE_VECTOR_WIDTH+3*NUM_THREADS*GLOBAL_WRITE_VECTOR_WIDTH + 1*MT0I*MT1J)];
+
+
+  /* LocalSplitU: global write indices */
+  unsigned int localC0I = (serial % (MT0I/GLOBAL_WRITE_VECTOR_WIDTH))*GLOBAL_WRITE_VECTOR_WIDTH;
+  unsigned int localC1J = serial / (MT0I/GLOBAL_WRITE_VECTOR_WIDTH);
+  unsigned int globalC0I = (wg0I)*MT0I + localC0I;
+  unsigned int globalC1J = (wg1J)*MT1J + localC1J;
+  unsigned int globalCK = (wgK);
+
+  /* LocalSplitU: global write */
+  if (globalC0I + 0 < size0I) {  if (globalC1J + 0*CPSV < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0, (unsigned long) globalC1J + 0*CPSV, (unsigned long) globalCK) ], alpha, rC[0 + 0*GLOBAL_WRITE_VECTOR_WIDTH], beta)} }
+  if (globalC0I + 1 < size0I) {  if (globalC1J + 0*CPSV < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1, (unsigned long) globalC1J + 0*CPSV, (unsigned long) globalCK) ], alpha, rC[1 + 0*GLOBAL_WRITE_VECTOR_WIDTH], beta)} }
+  if (globalC0I + 0 < size0I) {  if (globalC1J + 1*CPSV < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0, (unsigned long) globalC1J + 1*CPSV, (unsigned long) globalCK) ], alpha, rC[0 + 1*GLOBAL_WRITE_VECTOR_WIDTH], beta)} }
+  if (globalC0I + 1 < size0I) {  if (globalC1J + 1*CPSV < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1, (unsigned long) globalC1J + 1*CPSV, (unsigned long) globalCK) ], alpha, rC[1 + 1*GLOBAL_WRITE_VECTOR_WIDTH], beta)} }
+  if (globalC0I + 0 < size0I) {  if (globalC1J + 2*CPSV < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0, (unsigned long) globalC1J + 2*CPSV, (unsigned long) globalCK) ], alpha, rC[0 + 2*GLOBAL_WRITE_VECTOR_WIDTH], beta)} }
+  if (globalC0I + 1 < size0I) {  if (globalC1J + 2*CPSV < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1, (unsigned long) globalC1J + 2*CPSV, (unsigned long) globalCK) ], alpha, rC[1 + 2*GLOBAL_WRITE_VECTOR_WIDTH], beta)} }
+  if (globalC0I + 0 < size0I) {  if (globalC1J + 3*CPSV < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0, (unsigned long) globalC1J + 3*CPSV, (unsigned long) globalCK) ], alpha, rC[0 + 3*GLOBAL_WRITE_VECTOR_WIDTH], beta)} }
+  if (globalC0I + 1 < size0I) {  if (globalC1J + 3*CPSV < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1, (unsigned long) globalC1J + 3*CPSV, (unsigned long) globalCK) ], alpha, rC[1 + 3*GLOBAL_WRITE_VECTOR_WIDTH], beta)} }
+}
+);
+#endif
--- /dev/null
+++ b/src/library/blas/AutoGemm/UserGemmKernelSources/dgemm_TN_gfx906_tensile_src.cpp
@@ -0,0 +1,869 @@
+/*******************************************************************************
+ * Hand-tuned kernel
+ ******************************************************************************/
+
+#ifndef KERNEL_dgemm_TN_gfx906_TENSILE_SRC_H
+#define KERNEL_dgemm_TN_gfx906_TENSILE_SRC_H
+// #pragma message("AutoGemm's dgemm_TN_gfx906_tensile_src overriden by user.")
+
+const unsigned int dgemm_TN_gfx906_tensile_workGroupNumRows = 16;
+const unsigned int dgemm_TN_gfx906_tensile_workGroupNumCols = 16;
+const unsigned int dgemm_TN_gfx906_tensile_microTileNumRows = 4;
+const unsigned int dgemm_TN_gfx906_tensile_microTileNumCols = 4;
+
+#ifndef STRINGIFY
+#define STRINGIFY(S) STRINGIFY2(S)
+#define STRINGIFY2(S) #S
+#endif
+
+//if precompiled is enabled. All hand tuned kerenls should be precompiled.
+#ifndef AUTOGEMM_USE_PRE_COMPILED_KERNELS
+unsigned char *dgemm_TN_gfx906_tensile_bin = 0;
+size_t dgemm_TN_gfx906_tensile_binSize = 0;
+#endif
+
+const char * const dgemm_TN_gfx906_tensile_src = STRINGIFY(
+/******************************************/
+/* Function Prefix                        */
+/******************************************/
+
+/* tile parameters */
+#define NUM_THREADS 256
+#define SG0I 16
+#define SG1J 16
+#define TT0I 4
+#define TT1J 4
+#define MT0I (SG0I*TT0I)
+#define MT1J (SG1J*TT1J)
+#define VECTOR_WIDTH 2
+#define GLOBAL_LOAD_VECTOR_WIDTH_A 2
+#define GLOBAL_LOAD_VECTOR_WIDTH_B 2
+#define GLOBAL_WRITE_VECTOR_WIDTH 2
+
+/* DepthU parameters*/
+#define CPSV (NUM_THREADS / MT0I * VECTOR_WIDTH)
+#define LOCAL_SPLITU 1
+#define UNROLL 8
+#define LOCAL_DEPTHU (LOCAL_SPLITU*UNROLL)
+
+/* other */
+#define PAD 0
+#define WORK_GROUP_MAPPING 4
+
+/* num loads parallel and perpendicular to coalesced */
+#define NLCA 1
+#define NLCB 1
+#define NLPA 1
+#define NLPB 1
+
+/* load sizes parallel and perpendicular to coalesced */
+#define LSCA (LOCAL_DEPTHU/NLCA)
+#define LSPA (MT0I/NLPA)
+#define LSCB (LOCAL_DEPTHU/NLCB)
+#define LSPB (MT1J/NLPB)
+#define LVCA (LSCA/GLOBAL_LOAD_VECTOR_WIDTH_A)
+#define LVCB (LSCB/GLOBAL_LOAD_VECTOR_WIDTH_B)
+#define LVPA (LSPA/GLOBAL_LOAD_VECTOR_WIDTH_A)
+#define LVPB (LSPB/GLOBAL_LOAD_VECTOR_WIDTH_B)
+#define LDS_OFFSET_B 512
+#define LDS_NUM_ELEMENTS 2048
+#define LDS_OFFSET_BLK 1024
+
+/* global memory indices */
+#define GLOBAL_C(IDX0I, IDX1J, IDXK) (( (IDX0I)*strideC0I + (IDX1J)*strideC1J + (IDXK)*strideCK ))
+#define GLOBAL_OFFSET_A(IDXL, IDX0I, IDXK) (( (IDXL)*strideAL + (IDX0I)*strideA0I + (IDXK)*strideAK ))
+#define GLOBAL_OFFSET_B(IDXL, IDX1J, IDXK) (( (IDXL)*strideBL + (IDX1J)*strideB1J + (IDXK)*strideBK ))
+
+/* data types */
+#define DATA_TYPE double
+#define MAC(A,B,DST) mad(A,B,DST)
+
+/* MAC's */
+#define TYPE_MAC(MULA,MULB,DST) DST = MAC(MULA,MULB,DST);
+#define TYPE_MAC_WRITE(DST,ALPHA,REG,BETA) DST = 0 != (BETA) ? (ALPHA)*(REG) + (BETA)*(DST) : (ALPHA)*(REG);
+
+/* 4x4 micro-tile */
+#define MAC_4x4 \
+  TYPE_MAC(rA[0],rB[0],rC[0+0*TT0I]); \
+  TYPE_MAC(rA[1],rB[0],rC[1+0*TT0I]); \
+  TYPE_MAC(rA[2],rB[0],rC[2+0*TT0I]); \
+  TYPE_MAC(rA[3],rB[0],rC[3+0*TT0I]); \
+  TYPE_MAC(rA[0],rB[1],rC[0+1*TT0I]); \
+  TYPE_MAC(rA[1],rB[1],rC[1+1*TT0I]); \
+  TYPE_MAC(rA[2],rB[1],rC[2+1*TT0I]); \
+  TYPE_MAC(rA[3],rB[1],rC[3+1*TT0I]); \
+  TYPE_MAC(rA[0],rB[2],rC[0+2*TT0I]); \
+  TYPE_MAC(rA[1],rB[2],rC[1+2*TT0I]); \
+  TYPE_MAC(rA[2],rB[2],rC[2+2*TT0I]); \
+  TYPE_MAC(rA[3],rB[2],rC[3+2*TT0I]); \
+  TYPE_MAC(rA[0],rB[3],rC[0+3*TT0I]); \
+  TYPE_MAC(rA[1],rB[3],rC[1+3*TT0I]); \
+  TYPE_MAC(rA[2],rB[3],rC[2+3*TT0I]); \
+  TYPE_MAC(rA[3],rB[3],rC[3+3*TT0I]); \
+
+/* hard-coded initial strides */
+__constant unsigned int strideC0I = 1;
+__constant unsigned int strideAL = 1;
+__constant unsigned int strideBL = 1;
+
+  /******************************************/
+  /* Begin Kernel                           */
+  /******************************************/
+__attribute__((reqd_work_group_size(NUM_THREADS,1,1)))
+__kernel void Cijk_Alik_Bljk_DB_MT064x064x08_K1_PGR1_PLR0_TT04_04_WG16_16_01_WGM04(
+  __global double *C,
+  __global double const * restrict A,
+  __global double const * restrict B,
+  double const alpha,
+  double const beta,
+  unsigned int const offsetC,
+  unsigned int const offsetA,
+  unsigned int const offsetB,
+  unsigned int const strideC1J,
+  unsigned int const strideCK,
+  unsigned int const strideA0I,
+  unsigned int const strideAK,
+  unsigned int const strideB1J,
+  unsigned int const strideBK,
+  unsigned int const size0I,
+  unsigned int const size1J,
+  unsigned int const sizeK,
+  unsigned int const sizeL ) {
+
+  /******************************************/
+  /* Allocate Resources                     */
+  /******************************************/
+#define SCALAR_ZERO (double)(0)
+  DATA_TYPE rA[TT0I];
+  DATA_TYPE rB[TT1J];
+
+  /* registers for global->local */
+  DATA_TYPE a_0_0_0_0;
+  DATA_TYPE a_0_1_0_0;
+  DATA_TYPE b_0_0_0_0;
+  DATA_TYPE b_0_1_0_0;
+
+  /* allocate local memory */
+  __local DATA_TYPE localMemory[LDS_NUM_ELEMENTS];
+
+  /******************************************/
+  /* Global Read Addresses                  */
+  /******************************************/
+
+  /* global read addresses: subgroup */
+  unsigned int serial = get_local_id(0);
+  unsigned int sgId = serial / (SG0I*SG1J);
+
+  /* global read addresses: work-group */
+  unsigned int wg0I = get_group_id(0);
+  unsigned int wg1J = get_group_id(1);
+  unsigned int nwg0I = get_num_groups(0);
+  unsigned int nwg1J = get_num_groups(1);
+
+  unsigned long wgSerial = wg0I + (wg1J % WORK_GROUP_MAPPING) * nwg0I;
+  unsigned int block = wg1J / WORK_GROUP_MAPPING;
+  unsigned int blockRemainder = (wg1J < nwg1J-(nwg1J % WORK_GROUP_MAPPING) ) ? 0 : nwg1J % WORK_GROUP_MAPPING;
+  if ( blockRemainder == 0) {
+    wg0I = wgSerial / 4;
+    wg1J = wgSerial % 4 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 1) {
+    wg0I = wgSerial / 1;
+    wg1J = wgSerial % 1 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 2) {
+    wg0I = wgSerial / 2;
+    wg1J = wgSerial % 2 + block*WORK_GROUP_MAPPING;
+  } else {
+    wg0I = wgSerial / 3;
+    wg1J = wgSerial % 3 + block*WORK_GROUP_MAPPING;
+  }
+
+  /* global read addresses: tile offset assignment a */
+  unsigned int globalReadOffsetA0I = (serial/LVCA) + (wg0I)*MT0I;
+
+  /* global read addresses: tile offset assignment b */
+  unsigned int globalReadOffsetB1J = (serial/LVCB) + (wg1J)*MT1J;
+
+  /* global read addresses: unroll assignment a */
+  unsigned int globalReadOffsetAL = (serial%LVCA)*GLOBAL_LOAD_VECTOR_WIDTH_A;
+
+  /* global read addresses: unroll assignment b */
+  unsigned int globalReadOffsetBL = (serial%LVCB)*GLOBAL_LOAD_VECTOR_WIDTH_B;
+
+  /* global read addresses: other free assignments */
+  unsigned int wgK = ( get_group_id(2) ) % sizeK;
+
+  /* global read addresses: tile offsets a */
+  unsigned int globalReadOffsetA0I_0_0 = globalReadOffsetA0I + 0 + 0*LSPA;
+
+  /* global read addresses: tile offsets b */
+  unsigned int globalReadOffsetB1J_0_0 = globalReadOffsetB1J + 0 + 0*LSPB;
+
+  /* global read addresses: unroll offsets a */
+  unsigned int globalReadOffsetAL_0_0 = globalReadOffsetAL + 0 + 0*LSCA;
+
+  /* global read addresses: unroll offsets b */
+  unsigned int globalReadOffsetBL_0_0 = globalReadOffsetBL + 0 + 0*LSCB;
+
+  /* global read addresses: shift a */
+  globalReadOffsetA0I_0_0 = (  globalReadOffsetA0I_0_0 > size0I-1) ? size0I-1 : globalReadOffsetA0I_0_0;
+
+  /* global read addresses: shift b */
+  globalReadOffsetB1J_0_0 = (  globalReadOffsetB1J_0_0 > size1J-1) ? size1J-1 : globalReadOffsetB1J_0_0;
+
+  /* global read addresses: final offsets a */
+  unsigned long globalReadOffsetA_0_0_0_0 = GLOBAL_OFFSET_A( globalReadOffsetAL_0_0, globalReadOffsetA0I_0_0, wgK );
+
+  /* global read addresses: final offsets b */
+  unsigned long globalReadOffsetB_0_0_0_0 = GLOBAL_OFFSET_B( globalReadOffsetBL_0_0, globalReadOffsetB1J_0_0, wgK );
+
+  /* global read addresses: apply user offsets */
+  C += offsetC;
+  A += offsetA;
+  B += offsetB;
+
+  /* global read addresses: addresses a */
+  __global DATA_TYPE const *globalReadA_0_0_0_0 = A + globalReadOffsetA_0_0_0_0;
+
+  /* global read addresses: addresses b */
+  __global DATA_TYPE const *globalReadB_0_0_0_0 = B + globalReadOffsetB_0_0_0_0;
+
+  /* global read addresses: increments a */
+  long globalReadIncAL = (long)strideAL*LOCAL_DEPTHU;
+
+  /* global read addresses: increments b */
+  long globalReadIncBL = (long)strideBL*LOCAL_DEPTHU;
+
+  /******************************************/
+  /* Local Write Addresses                  */
+  /******************************************/
+
+  /* local write addresses: tile assignment a */
+  unsigned int lwA0I = (serial/LVCA);
+
+  /* local write addresses: tile assignment b */
+  unsigned int lwB1J = (serial/LVCB);
+
+  /* local write addresses: unroll assignment a */
+  unsigned int lwAL = (serial%LVCA)*GLOBAL_LOAD_VECTOR_WIDTH_A;
+
+  /* local write addresses: unroll assignment b */
+  unsigned int lwBL = (serial%LVCB)*GLOBAL_LOAD_VECTOR_WIDTH_B;
+
+  /* local write addresses: first offset a */
+  unsigned int localWriteFirstOffsetA = lwA0I + lwAL*(MT0I+PAD);
+
+  /* local write addresses: first offset b */
+  unsigned int localWriteFirstOffsetB = lwB1J + lwBL*(MT1J+PAD) + LDS_OFFSET_B;
+
+  /* local write addresses: final offsets a */
+  unsigned int localWriteOffsetA_0_0_0_0 = localWriteFirstOffsetA + (0 + 0*LSCA)*(MT0I+PAD) + (0 + 0*LSPA);
+  unsigned int localWriteOffsetA_0_0_0_1 = localWriteFirstOffsetA + (1 + 0*LSCA)*(MT0I+PAD) + (0 + 0*LSPA);
+
+  /* local write addresses: final offsets b */
+  unsigned int localWriteOffsetB_0_0_0_0 = localWriteFirstOffsetB + (0 + 0*LSCB)*(MT1J+PAD) + (0 + 0*LSPB);
+  unsigned int localWriteOffsetB_0_0_0_1 = localWriteFirstOffsetB + (1 + 0*LSCB)*(MT1J+PAD) + (0 + 0*LSPB);
+
+  /* local write addresses: declare addresses a */
+  __local DATA_TYPE *localWriteA_0_0_0_0;
+  __local DATA_TYPE *localWriteA_0_0_0_1;
+
+  /* local write addresses: declare addresses b */
+  __local DATA_TYPE *localWriteB_0_0_0_0;
+  __local DATA_TYPE *localWriteB_0_0_0_1;
+
+  /* local write addresses: init pointers a */
+  localWriteA_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_0);
+  localWriteA_0_0_0_1 = (__local DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_1);
+
+  /* local write addresses: init pointers b */
+  localWriteB_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_0_0);
+  localWriteB_0_0_0_1 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_0_1);
+
+  /******************************************/
+  /* Local Read Addresses                   */
+  /******************************************/
+
+  /* local read addresses: tile assignments a */
+  unsigned int lr0I = (serial % SG0I);
+
+  /* local read addresses: tile assignments b */
+  unsigned int lr1J = (serial / SG0I) % SG1J;
+
+  /* local read addresses: final offsets a */
+  unsigned int localReadOffsetA = lr0I*VECTOR_WIDTH + sgId*(MT0I+PAD);
+
+  /* local read addresses: final offsets b */
+  unsigned int localReadOffsetB = lr1J*VECTOR_WIDTH + sgId*(MT1J+PAD) + LDS_OFFSET_B;
+
+  /* local read addresses: declare addresses a */
+  __local DATA_TYPE *localReadA;
+
+  /* local read addresses: declare addresses b */
+  __local DATA_TYPE *localReadB;
+
+  /* declare loop num iterations */
+  unsigned int numIterL;
+
+  /* registers for MAC's */
+  DATA_TYPE rC[TT0I*TT1J];
+  rC[0] = SCALAR_ZERO;
+  rC[1] = SCALAR_ZERO;
+  rC[2] = SCALAR_ZERO;
+  rC[3] = SCALAR_ZERO;
+  rC[4] = SCALAR_ZERO;
+  rC[5] = SCALAR_ZERO;
+  rC[6] = SCALAR_ZERO;
+  rC[7] = SCALAR_ZERO;
+  rC[8] = SCALAR_ZERO;
+  rC[9] = SCALAR_ZERO;
+  rC[10] = SCALAR_ZERO;
+  rC[11] = SCALAR_ZERO;
+  rC[12] = SCALAR_ZERO;
+  rC[13] = SCALAR_ZERO;
+  rC[14] = SCALAR_ZERO;
+  rC[15] = SCALAR_ZERO;
+  numIterL = sizeL / LOCAL_DEPTHU;
+
+  /* local read addresses: init pointers a */
+  localReadA = (__local DATA_TYPE *)(localMemory + localReadOffsetA);
+
+  /* local read addresses: init pointers b */
+  localReadB = (__local DATA_TYPE *)(localMemory + localReadOffsetB);
+
+  /* prefetch: global -> local */
+  if (sizeL >= LOCAL_DEPTHU) {
+
+    /* global read a */
+    a_0_0_0_0 = *(globalReadA_0_0_0_0 + 0);
+    a_0_1_0_0 = *(globalReadA_0_0_0_0 + 1);
+
+    /* global read b */
+    b_0_0_0_0 = *(globalReadB_0_0_0_0 + 0);
+    b_0_1_0_0 = *(globalReadB_0_0_0_0 + 1);
+
+    /* global read inc a */
+    globalReadA_0_0_0_0 = (__global DATA_TYPE const *)( ((__global DATA_TYPE const *)globalReadA_0_0_0_0) + globalReadIncAL);
+
+    /* global read inc b */
+    globalReadB_0_0_0_0 = (__global DATA_TYPE const *)( ((__global DATA_TYPE const *)globalReadB_0_0_0_0) + globalReadIncBL);
+
+    /* local write a */
+    *(localWriteA_0_0_0_0 + 0) = a_0_0_0_0;
+    *(localWriteA_0_0_0_1 + 0) = a_0_1_0_0;
+
+    /* local write b */
+    *(localWriteB_0_0_0_0 + 0) = b_0_0_0_0;
+    *(localWriteB_0_0_0_1 + 0) = b_0_1_0_0;
+
+    /* local write swap a */
+    localWriteOffsetA_0_0_0_0 = (localWriteOffsetA_0_0_0_0 + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+    localWriteOffsetA_0_0_0_1 = (localWriteOffsetA_0_0_0_1 + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+
+    /* local write swap b */
+    localWriteOffsetB_0_0_0_0 = (localWriteOffsetB_0_0_0_0 + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+    localWriteOffsetB_0_0_0_1 = (localWriteOffsetB_0_0_0_1 + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+
+    /* local write init pointers a */
+    localWriteA_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_0);
+    localWriteA_0_0_0_1 = (__local DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_1);
+
+    /* local write init pointers b */
+    localWriteB_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_0_0);
+    localWriteB_0_0_0_1 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_0_1);
+  }
+
+  /******************************************/
+  /* Unrolled Loop - Begin                  */
+  /******************************************/
+  while (numIterL-- > 1) {
+
+    /* global read a */
+    a_0_0_0_0 = *(globalReadA_0_0_0_0 + 0);
+    a_0_1_0_0 = *(globalReadA_0_0_0_0 + 1);
+
+    /* global read b */
+    b_0_0_0_0 = *(globalReadB_0_0_0_0 + 0);
+    b_0_1_0_0 = *(globalReadB_0_0_0_0 + 1);
+
+    /* global read inc a */
+    globalReadA_0_0_0_0 = (__global DATA_TYPE const *)( ((__global DATA_TYPE const *)globalReadA_0_0_0_0) + globalReadIncAL);
+
+    /* global read inc b */
+    globalReadB_0_0_0_0 = (__global DATA_TYPE const *)( ((__global DATA_TYPE const *)globalReadB_0_0_0_0) + globalReadIncBL);
+    barrier(CLK_LOCAL_MEM_FENCE);
+
+    /* iter 0 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 1 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 2 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 3 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 4 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 5 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 6 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 7 (last) */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local write a */
+    *(localWriteA_0_0_0_0 + 0) = a_0_0_0_0;
+    *(localWriteA_0_0_0_1 + 0) = a_0_1_0_0;
+
+    /* local write b */
+    *(localWriteB_0_0_0_0 + 0) = b_0_0_0_0;
+    *(localWriteB_0_0_0_1 + 0) = b_0_1_0_0;
+
+    /* local write swap offsets a */
+    localWriteOffsetA_0_0_0_0 = (localWriteOffsetA_0_0_0_0 + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+    localWriteOffsetA_0_0_0_1 = (localWriteOffsetA_0_0_0_1 + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+
+    /* local write swap offsets b */
+    localWriteOffsetB_0_0_0_0 = (localWriteOffsetB_0_0_0_0 + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+    localWriteOffsetB_0_0_0_1 = (localWriteOffsetB_0_0_0_1 + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+
+    /* local write init pointers a */
+    localWriteA_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_0);
+    localWriteA_0_0_0_1 = (__local DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_1);
+
+    /* local write init pointers b */
+    localWriteB_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_0_0);
+    localWriteB_0_0_0_1 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_0_1);
+
+    /* local read swap offsets a */
+    localReadOffsetA = (localReadOffsetA + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+
+    /* local read swap offsets b */
+    localReadOffsetB = (localReadOffsetB + LDS_OFFSET_BLK)%(LDS_OFFSET_BLK*2);
+
+    /* local read init pointers a */
+    localReadA = (__local DATA_TYPE *)(localMemory + localReadOffsetA);
+
+    /* local read init pointers b */
+    localReadB = (__local DATA_TYPE *)(localMemory + localReadOffsetB);
+    MAC_4x4
+
+    /******************************************/
+    /* Unrolled Loop - End                    */
+    /******************************************/
+  }
+
+  /* prefetch: last unrolled iteration */
+  if (sizeL >= LOCAL_DEPTHU) {
+    barrier(CLK_LOCAL_MEM_FENCE);
+
+    /* iter 0 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 1 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 2 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 3 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 4 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 5 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 6 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+
+    /* iter 7 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+  }
+
+  /******************************************/
+  /* Tail Loop                              */
+  /******************************************/
+
+  /* local write reset offsets a */
+  localWriteOffsetA_0_0_0_0 %= LDS_OFFSET_BLK;
+  localWriteOffsetA_0_0_0_1 %= LDS_OFFSET_BLK;
+
+  /* local write reset offsets b */
+  localWriteOffsetB_0_0_0_0 %= LDS_OFFSET_BLK;
+  localWriteOffsetB_0_0_0_1 %= LDS_OFFSET_BLK;
+  numIterL = (((sizeL % LOCAL_DEPTHU) + LOCAL_SPLITU - 1) / LOCAL_SPLITU);
+
+  /* global read a */
+  a_0_0_0_0 = ( globalReadOffsetAL_0_0 + 0 >= (sizeL % LOCAL_DEPTHU) ) ? SCALAR_ZERO : *(globalReadA_0_0_0_0 + 0);
+  a_0_1_0_0 = ( globalReadOffsetAL_0_0 + 1 >= (sizeL % LOCAL_DEPTHU) ) ? SCALAR_ZERO : *(globalReadA_0_0_0_0 + 1);
+
+  /* global read b */
+  b_0_0_0_0 = ( globalReadOffsetBL_0_0 + 0 >= (sizeL % LOCAL_DEPTHU) ) ? SCALAR_ZERO : *(globalReadB_0_0_0_0 + 0);
+  b_0_1_0_0 = ( globalReadOffsetBL_0_0 + 1 >= (sizeL % LOCAL_DEPTHU) ) ? SCALAR_ZERO : *(globalReadB_0_0_0_0 + 1);
+  barrier(CLK_LOCAL_MEM_FENCE);
+
+  /* local write init pointers a */
+  localWriteA_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_0);
+  localWriteA_0_0_0_1 = (__local DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_1);
+
+  /* local write init pointers b */
+  localWriteB_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_0_0);
+  localWriteB_0_0_0_1 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_0_1);
+
+  /* local write a */
+  *(localWriteA_0_0_0_0 + 0) = a_0_0_0_0;
+  *(localWriteA_0_0_0_1 + 0) = a_0_1_0_0;
+
+  /* local write b */
+  *(localWriteB_0_0_0_0 + 0) = b_0_0_0_0;
+  *(localWriteB_0_0_0_1 + 0) = b_0_1_0_0;
+  barrier(CLK_LOCAL_MEM_FENCE);
+
+  /* local read reset offsets a */
+  localReadOffsetA %= LDS_OFFSET_BLK;
+
+  /* local read reset offsets b */
+  localReadOffsetB %= LDS_OFFSET_BLK;
+
+  /* local read init pointers a */
+  localReadA = (__local DATA_TYPE *)(localMemory + localReadOffsetA);
+
+  /* local read init pointers b */
+  localReadB = (__local DATA_TYPE *)(localMemory + localReadOffsetB);
+
+  /* tail loop: macs */
+  while (numIterL-- > 0) {
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x4
+  }
+
+  /* not-LocalSplitU: global write indices */
+  unsigned int globalC0I = (wg0I)*MT0I + (serial % SG0I)*VECTOR_WIDTH;
+  unsigned int globalC1J = (wg1J)*MT1J + (serial / SG0I)*VECTOR_WIDTH;
+  unsigned int globalCK = (wgK);
+
+  /* not-LocalSplitU: global write */
+  if (globalC0I + 0 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+0 + (0*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 1 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+1 + (0*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 0 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+0 + (0*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 1 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+1 + (0*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 0 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+0 + (0*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 1 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+1 + (0*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 0 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+0 + (0*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 1 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+1 + (0*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 0 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+0 + (1*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 1 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+1 + (1*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 0 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+0 + (1*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 1 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+1 + (1*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 0 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+0 + (1*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 1 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+1 + (1*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 0 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+0 + (1*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 1 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+1 + (1*VECTOR_WIDTH+1)*TT0I], beta) } }
+}
+);
+#endif
--- /dev/null
+++ b/src/library/blas/AutoGemm/UserGemmKernelSources/dgemm_TT_gfx906_tensile_src.cpp
@@ -0,0 +1,921 @@
+/*******************************************************************************
+ * Hand-tuned kernel
+ ******************************************************************************/
+
+#ifndef KERNEL_DGEMM_TT_GFX906_TENSILE_SRC_H
+#define KERNEL_DGEMM_TT_GFX906_TENSILE_SRC_H
+// #pragma message("AutoGemm's dgemm_TT_gfx906_tensile_src overriden by user.")
+
+const unsigned int dgemm_TT_gfx906_tensile_workGroupNumRows = 16;
+const unsigned int dgemm_TT_gfx906_tensile_workGroupNumCols = 16;
+const unsigned int dgemm_TT_gfx906_tensile_microTileNumRows = 4;
+const unsigned int dgemm_TT_gfx906_tensile_microTileNumCols = 8;
+
+#ifndef STRINGIFY
+#define STRINGIFY(S) STRINGIFY2(S)
+#define STRINGIFY2(S) #S
+#endif
+
+//if precompiled is enabled. All hand tuned kerenls should be precompiled.
+#ifndef AUTOGEMM_USE_PRE_COMPILED_KERNELS
+unsigned char *dgemm_TT_gfx906_tensile_bin = 0;
+size_t dgemm_TT_gfx906_tensile_binSize = 0;
+#endif
+
+const char * const dgemm_TT_gfx906_tensile_src = STRINGIFY(
+/******************************************/
+/* Function Prefix                        */
+/******************************************/
+
+/* tile parameters */
+#define NUM_THREADS 256
+#define SG0I 16
+#define SG1J 16
+#define TT0I 4
+#define TT1J 8
+#define MT0I (SG0I*TT0I)
+#define MT1J (SG1J*TT1J)
+#define VECTOR_WIDTH 2
+#define GLOBAL_LOAD_VECTOR_WIDTH_A 2
+#define GLOBAL_LOAD_VECTOR_WIDTH_B 2
+#define GLOBAL_WRITE_VECTOR_WIDTH 2
+
+/* DepthU parameters*/
+#define CPSV (NUM_THREADS / MT0I * VECTOR_WIDTH)
+#define LOCAL_SPLITU 1
+#define UNROLL 8
+#define LOCAL_DEPTHU (LOCAL_SPLITU*UNROLL)
+
+/* other */
+#define PAD 0
+#define WORK_GROUP_MAPPING 64
+
+/* num loads parallel and perpendicular to coalesced */
+#define NLCA 1
+#define NLCB 1
+#define NLPA 1
+#define NLPB 2
+
+/* load sizes parallel and perpendicular to coalesced */
+#define LSCA (LOCAL_DEPTHU/NLCA)
+#define LSPA (MT0I/NLPA)
+#define LSCB (MT1J/NLCB)
+#define LSPB (LOCAL_DEPTHU/NLPB)
+#define LVCA (LSCA/GLOBAL_LOAD_VECTOR_WIDTH_A)
+#define LVCB (LSCB/GLOBAL_LOAD_VECTOR_WIDTH_B)
+#define LVPA (LSPA/GLOBAL_LOAD_VECTOR_WIDTH_A)
+#define LVPB (LSPB/GLOBAL_LOAD_VECTOR_WIDTH_B)
+#define LDS_OFFSET_B 512
+#define LDS_NUM_ELEMENTS 1536
+
+/* global memory indices */
+#define GLOBAL_C(IDX0I, IDX1J, IDXK) (( (IDX0I)*strideC0I + (IDX1J)*strideC1J + (IDXK)*strideCK ))
+#define GLOBAL_OFFSET_A(IDXL, IDX0I, IDXK) (( (IDXL)*strideAL + (IDX0I)*strideA0I + (IDXK)*strideAK ))
+#define GLOBAL_OFFSET_B(IDX1J, IDXL, IDXK) (( (IDX1J)*strideB1J + (IDXL)*strideBL + (IDXK)*strideBK ))
+
+/* data types */
+#define DATA_TYPE double
+#define MAC(A,B,DST) mad(A,B,DST)
+
+/* MAC's */
+#define TYPE_MAC(MULA,MULB,DST) DST = MAC(MULA,MULB,DST);
+#define TYPE_MAC_WRITE(DST,ALPHA,REG,BETA) DST = 0 != (BETA) ? (ALPHA)*(REG) + (BETA)*(DST) : (ALPHA)*(REG);
+
+/* 4x8 micro-tile */
+#define MAC_4x8 \
+  TYPE_MAC(rA[0],rB[0],rC[0+0*TT0I]); \
+  TYPE_MAC(rA[1],rB[0],rC[1+0*TT0I]); \
+  TYPE_MAC(rA[2],rB[0],rC[2+0*TT0I]); \
+  TYPE_MAC(rA[3],rB[0],rC[3+0*TT0I]); \
+  TYPE_MAC(rA[0],rB[1],rC[0+1*TT0I]); \
+  TYPE_MAC(rA[1],rB[1],rC[1+1*TT0I]); \
+  TYPE_MAC(rA[2],rB[1],rC[2+1*TT0I]); \
+  TYPE_MAC(rA[3],rB[1],rC[3+1*TT0I]); \
+  TYPE_MAC(rA[0],rB[2],rC[0+2*TT0I]); \
+  TYPE_MAC(rA[1],rB[2],rC[1+2*TT0I]); \
+  TYPE_MAC(rA[2],rB[2],rC[2+2*TT0I]); \
+  TYPE_MAC(rA[3],rB[2],rC[3+2*TT0I]); \
+  TYPE_MAC(rA[0],rB[3],rC[0+3*TT0I]); \
+  TYPE_MAC(rA[1],rB[3],rC[1+3*TT0I]); \
+  TYPE_MAC(rA[2],rB[3],rC[2+3*TT0I]); \
+  TYPE_MAC(rA[3],rB[3],rC[3+3*TT0I]); \
+  TYPE_MAC(rA[0],rB[4],rC[0+4*TT0I]); \
+  TYPE_MAC(rA[1],rB[4],rC[1+4*TT0I]); \
+  TYPE_MAC(rA[2],rB[4],rC[2+4*TT0I]); \
+  TYPE_MAC(rA[3],rB[4],rC[3+4*TT0I]); \
+  TYPE_MAC(rA[0],rB[5],rC[0+5*TT0I]); \
+  TYPE_MAC(rA[1],rB[5],rC[1+5*TT0I]); \
+  TYPE_MAC(rA[2],rB[5],rC[2+5*TT0I]); \
+  TYPE_MAC(rA[3],rB[5],rC[3+5*TT0I]); \
+  TYPE_MAC(rA[0],rB[6],rC[0+6*TT0I]); \
+  TYPE_MAC(rA[1],rB[6],rC[1+6*TT0I]); \
+  TYPE_MAC(rA[2],rB[6],rC[2+6*TT0I]); \
+  TYPE_MAC(rA[3],rB[6],rC[3+6*TT0I]); \
+  TYPE_MAC(rA[0],rB[7],rC[0+7*TT0I]); \
+  TYPE_MAC(rA[1],rB[7],rC[1+7*TT0I]); \
+  TYPE_MAC(rA[2],rB[7],rC[2+7*TT0I]); \
+  TYPE_MAC(rA[3],rB[7],rC[3+7*TT0I]); \
+
+/* hard-coded initial strides */
+__constant unsigned int strideC0I = 1;
+__constant unsigned int strideAL = 1;
+__constant unsigned int strideB1J = 1;
+
+  /******************************************/
+  /* Begin Kernel                           */
+  /******************************************/
+__attribute__((reqd_work_group_size(NUM_THREADS,1,1)))
+__kernel void Cijk_Alik_Bjlk_DB_MT064x128x08_K1_PGR0_PLR0_TT04_08_WG16_16_01_WGM64(
+  __global double *C,
+  __global double const * restrict A,
+  __global double const * restrict B,
+  double const alpha,
+  double const beta,
+  unsigned int const offsetC,
+  unsigned int const offsetA,
+  unsigned int const offsetB,
+  unsigned int const strideC1J,
+  unsigned int const strideCK,
+  unsigned int const strideA0I,
+  unsigned int const strideAK,
+  unsigned int const strideBL,
+  unsigned int const strideBK,
+  unsigned int const size0I,
+  unsigned int const size1J,
+  unsigned int const sizeK,
+  unsigned int const sizeL ) {
+
+  /******************************************/
+  /* Allocate Resources                     */
+  /******************************************/
+#define SCALAR_ZERO (double)(0)
+  DATA_TYPE rA[TT0I];
+  DATA_TYPE rB[TT1J];
+
+  /* registers for global->local */
+  DATA_TYPE a_0_0_0_0;
+  DATA_TYPE a_0_1_0_0;
+  DATA_TYPE b_0_0_0_0;
+  DATA_TYPE b_0_1_0_0;
+  DATA_TYPE b_0_0_1_0;
+  DATA_TYPE b_0_1_1_0;
+
+  /* allocate local memory */
+  __local DATA_TYPE localMemory[LDS_NUM_ELEMENTS];
+
+  /******************************************/
+  /* Global Read Addresses                  */
+  /******************************************/
+
+  /* global read addresses: subgroup */
+  unsigned int serial = get_local_id(0);
+  unsigned int sgId = serial / (SG0I*SG1J);
+
+  /* global read addresses: work-group */
+  unsigned int wg0I = get_group_id(0);
+  unsigned int wg1J = get_group_id(1);
+  unsigned int nwg0I = get_num_groups(0);
+  unsigned int nwg1J = get_num_groups(1);
+
+  unsigned long wgSerial = wg0I + (wg1J % WORK_GROUP_MAPPING) * nwg0I;
+  unsigned int block = wg1J / WORK_GROUP_MAPPING;
+  unsigned int blockRemainder = (wg1J < nwg1J-(nwg1J % WORK_GROUP_MAPPING) ) ? 0 : nwg1J % WORK_GROUP_MAPPING;
+  if ( blockRemainder == 0) {
+    wg0I = wgSerial / 64;
+    wg1J = wgSerial % 64 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 1) {
+    wg0I = wgSerial / 1;
+    wg1J = wgSerial % 1 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 2) {
+    wg0I = wgSerial / 2;
+    wg1J = wgSerial % 2 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 3) {
+    wg0I = wgSerial / 3;
+    wg1J = wgSerial % 3 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 4) {
+    wg0I = wgSerial / 4;
+    wg1J = wgSerial % 4 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 5) {
+    wg0I = wgSerial / 5;
+    wg1J = wgSerial % 5 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 6) {
+    wg0I = wgSerial / 6;
+    wg1J = wgSerial % 6 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 7) {
+    wg0I = wgSerial / 7;
+    wg1J = wgSerial % 7 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 8) {
+    wg0I = wgSerial / 8;
+    wg1J = wgSerial % 8 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 9) {
+    wg0I = wgSerial / 9;
+    wg1J = wgSerial % 9 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 10) {
+    wg0I = wgSerial / 10;
+    wg1J = wgSerial % 10 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 11) {
+    wg0I = wgSerial / 11;
+    wg1J = wgSerial % 11 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 12) {
+    wg0I = wgSerial / 12;
+    wg1J = wgSerial % 12 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 13) {
+    wg0I = wgSerial / 13;
+    wg1J = wgSerial % 13 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 14) {
+    wg0I = wgSerial / 14;
+    wg1J = wgSerial % 14 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 15) {
+    wg0I = wgSerial / 15;
+    wg1J = wgSerial % 15 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 16) {
+    wg0I = wgSerial / 16;
+    wg1J = wgSerial % 16 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 17) {
+    wg0I = wgSerial / 17;
+    wg1J = wgSerial % 17 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 18) {
+    wg0I = wgSerial / 18;
+    wg1J = wgSerial % 18 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 19) {
+    wg0I = wgSerial / 19;
+    wg1J = wgSerial % 19 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 20) {
+    wg0I = wgSerial / 20;
+    wg1J = wgSerial % 20 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 21) {
+    wg0I = wgSerial / 21;
+    wg1J = wgSerial % 21 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 22) {
+    wg0I = wgSerial / 22;
+    wg1J = wgSerial % 22 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 23) {
+    wg0I = wgSerial / 23;
+    wg1J = wgSerial % 23 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 24) {
+    wg0I = wgSerial / 24;
+    wg1J = wgSerial % 24 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 25) {
+    wg0I = wgSerial / 25;
+    wg1J = wgSerial % 25 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 26) {
+    wg0I = wgSerial / 26;
+    wg1J = wgSerial % 26 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 27) {
+    wg0I = wgSerial / 27;
+    wg1J = wgSerial % 27 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 28) {
+    wg0I = wgSerial / 28;
+    wg1J = wgSerial % 28 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 29) {
+    wg0I = wgSerial / 29;
+    wg1J = wgSerial % 29 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 30) {
+    wg0I = wgSerial / 30;
+    wg1J = wgSerial % 30 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 31) {
+    wg0I = wgSerial / 31;
+    wg1J = wgSerial % 31 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 32) {
+    wg0I = wgSerial / 32;
+    wg1J = wgSerial % 32 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 33) {
+    wg0I = wgSerial / 33;
+    wg1J = wgSerial % 33 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 34) {
+    wg0I = wgSerial / 34;
+    wg1J = wgSerial % 34 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 35) {
+    wg0I = wgSerial / 35;
+    wg1J = wgSerial % 35 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 36) {
+    wg0I = wgSerial / 36;
+    wg1J = wgSerial % 36 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 37) {
+    wg0I = wgSerial / 37;
+    wg1J = wgSerial % 37 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 38) {
+    wg0I = wgSerial / 38;
+    wg1J = wgSerial % 38 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 39) {
+    wg0I = wgSerial / 39;
+    wg1J = wgSerial % 39 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 40) {
+    wg0I = wgSerial / 40;
+    wg1J = wgSerial % 40 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 41) {
+    wg0I = wgSerial / 41;
+    wg1J = wgSerial % 41 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 42) {
+    wg0I = wgSerial / 42;
+    wg1J = wgSerial % 42 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 43) {
+    wg0I = wgSerial / 43;
+    wg1J = wgSerial % 43 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 44) {
+    wg0I = wgSerial / 44;
+    wg1J = wgSerial % 44 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 45) {
+    wg0I = wgSerial / 45;
+    wg1J = wgSerial % 45 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 46) {
+    wg0I = wgSerial / 46;
+    wg1J = wgSerial % 46 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 47) {
+    wg0I = wgSerial / 47;
+    wg1J = wgSerial % 47 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 48) {
+    wg0I = wgSerial / 48;
+    wg1J = wgSerial % 48 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 49) {
+    wg0I = wgSerial / 49;
+    wg1J = wgSerial % 49 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 50) {
+    wg0I = wgSerial / 50;
+    wg1J = wgSerial % 50 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 51) {
+    wg0I = wgSerial / 51;
+    wg1J = wgSerial % 51 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 52) {
+    wg0I = wgSerial / 52;
+    wg1J = wgSerial % 52 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 53) {
+    wg0I = wgSerial / 53;
+    wg1J = wgSerial % 53 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 54) {
+    wg0I = wgSerial / 54;
+    wg1J = wgSerial % 54 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 55) {
+    wg0I = wgSerial / 55;
+    wg1J = wgSerial % 55 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 56) {
+    wg0I = wgSerial / 56;
+    wg1J = wgSerial % 56 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 57) {
+    wg0I = wgSerial / 57;
+    wg1J = wgSerial % 57 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 58) {
+    wg0I = wgSerial / 58;
+    wg1J = wgSerial % 58 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 59) {
+    wg0I = wgSerial / 59;
+    wg1J = wgSerial % 59 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 60) {
+    wg0I = wgSerial / 60;
+    wg1J = wgSerial % 60 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 61) {
+    wg0I = wgSerial / 61;
+    wg1J = wgSerial % 61 + block*WORK_GROUP_MAPPING;
+  } else if ( blockRemainder == 62) {
+    wg0I = wgSerial / 62;
+    wg1J = wgSerial % 62 + block*WORK_GROUP_MAPPING;
+  } else {
+    wg0I = wgSerial / 63;
+    wg1J = wgSerial % 63 + block*WORK_GROUP_MAPPING;
+  }
+
+  /* global read addresses: tile offset assignment a */
+  unsigned int globalReadOffsetA0I = (serial/LVCA) + (wg0I)*MT0I;
+
+  /* global read addresses: tile offset assignment b */
+  unsigned int globalReadOffsetB1J = (serial%LVCB)*GLOBAL_LOAD_VECTOR_WIDTH_B + (wg1J)*MT1J;
+
+  /* global read addresses: unroll assignment a */
+  unsigned int globalReadOffsetAL = (serial%LVCA)*GLOBAL_LOAD_VECTOR_WIDTH_A;
+
+  /* global read addresses: unroll assignment b */
+  unsigned int globalReadOffsetBL = (serial/LVCB);
+
+  /* global read addresses: other free assignments */
+  unsigned int wgK = ( get_group_id(2) ) % sizeK;
+
+  /* global read addresses: tile offsets a */
+  unsigned int globalReadOffsetA0I_0_0 = globalReadOffsetA0I + 0 + 0*LSPA;
+
+  /* global read addresses: tile offsets b */
+  unsigned int globalReadOffsetB1J_0_0 = globalReadOffsetB1J + 0 + 0*LSCB;
+
+  /* global read addresses: unroll offsets a */
+  unsigned int globalReadOffsetAL_0_0 = globalReadOffsetAL + 0 + 0*LSCA;
+
+  /* global read addresses: unroll offsets b */
+  unsigned int globalReadOffsetBL_0_0 = globalReadOffsetBL + 0 + 0*LSPB;
+  unsigned int globalReadOffsetBL_1_0 = globalReadOffsetBL + 0 + 1*LSPB;
+
+  /* global read addresses: shift a */
+  globalReadOffsetA0I_0_0 = (  globalReadOffsetA0I_0_0 > size0I-1) ? size0I-1 : globalReadOffsetA0I_0_0;
+
+  /* global read addresses: shift b */
+  globalReadOffsetB1J_0_0 = (  globalReadOffsetB1J_0_0 > size1J-GLOBAL_LOAD_VECTOR_WIDTH_B+0) ? size1J-GLOBAL_LOAD_VECTOR_WIDTH_B+0 : globalReadOffsetB1J_0_0;
+
+  /* global read addresses: final offsets a */
+  unsigned long globalReadOffsetA_0_0_0_0 = GLOBAL_OFFSET_A( globalReadOffsetAL_0_0, globalReadOffsetA0I_0_0, wgK );
+
+  /* global read addresses: final offsets b */
+  unsigned long globalReadOffsetB_0_0_0_0 = GLOBAL_OFFSET_B( globalReadOffsetB1J_0_0, globalReadOffsetBL_0_0, wgK );
+  unsigned long globalReadOffsetB_0_0_1_0 = GLOBAL_OFFSET_B( globalReadOffsetB1J_0_0, globalReadOffsetBL_1_0, wgK );
+
+  /* global read addresses: apply user offsets */
+  C += offsetC;
+  A += offsetA;
+  B += offsetB;
+
+  /* global read addresses: addresses a */
+  __global DATA_TYPE const *globalReadA_0_0_0_0 = A + globalReadOffsetA_0_0_0_0;
+
+  /* global read addresses: addresses b */
+  __global DATA_TYPE const *globalReadB_0_0_0_0 = B + globalReadOffsetB_0_0_0_0;
+  __global DATA_TYPE const *globalReadB_0_0_1_0 = B + globalReadOffsetB_0_0_1_0;
+
+  /* global read addresses: increments a */
+  long globalReadIncAL = (long)strideAL*LOCAL_DEPTHU;
+
+  /* global read addresses: increments b */
+  long globalReadIncBL = (long)strideBL*LOCAL_DEPTHU;
+
+  /******************************************/
+  /* Local Write Addresses                  */
+  /******************************************/
+
+  /* local write addresses: tile assignment a */
+  unsigned int lwA0I = (serial/LVCA);
+
+  /* local write addresses: tile assignment b */
+  unsigned int lwB1J = (serial%LVCB)*GLOBAL_LOAD_VECTOR_WIDTH_B;
+
+  /* local write addresses: unroll assignment a */
+  unsigned int lwAL = (serial%LVCA)*GLOBAL_LOAD_VECTOR_WIDTH_A;
+
+  /* local write addresses: unroll assignment b */
+  unsigned int lwBL = (serial/LVCB);
+
+  /* local write addresses: first offset a */
+  unsigned int localWriteFirstOffsetA = lwA0I + lwAL*(MT0I+PAD);
+
+  /* local write addresses: first offset b */
+  unsigned int localWriteFirstOffsetB = lwB1J + lwBL*(MT1J+PAD) + LDS_OFFSET_B;
+
+  /* local write addresses: final offsets a */
+  unsigned int localWriteOffsetA_0_0_0_0 = localWriteFirstOffsetA + (0 + 0*LSCA)*(MT0I+PAD) + (0 + 0*LSPA);
+  unsigned int localWriteOffsetA_0_0_0_1 = localWriteFirstOffsetA + (1 + 0*LSCA)*(MT0I+PAD) + (0 + 0*LSPA);
+
+  /* local write addresses: final offsets b */
+  unsigned int localWriteOffsetB_0_0_0_0 = localWriteFirstOffsetB + (0 + 0*LSCB) + (0 + 0*LSPB)*(MT1J+PAD);
+  unsigned int localWriteOffsetB_0_0_1_0 = localWriteFirstOffsetB + (0 + 0*LSCB) + (0 + 1*LSPB)*(MT1J+PAD);
+
+  /* local write addresses: declare addresses a */
+  __local DATA_TYPE *localWriteA_0_0_0_0;
+  __local DATA_TYPE *localWriteA_0_0_0_1;
+
+  /* local write addresses: declare addresses b */
+  __local DATA_TYPE *localWriteB_0_0_0_0;
+  __local DATA_TYPE *localWriteB_0_0_1_0;
+
+  /* local write addresses: init pointers a */
+  localWriteA_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_0);
+  localWriteA_0_0_0_1 = (__local DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_1);
+
+  /* local write addresses: init pointers b */
+  localWriteB_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_0_0);
+  localWriteB_0_0_1_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_1_0);
+
+  /******************************************/
+  /* Local Read Addresses                   */
+  /******************************************/
+
+  /* local read addresses: tile assignments a */
+  unsigned int lr0I = (serial % SG0I);
+
+  /* local read addresses: tile assignments b */
+  unsigned int lr1J = (serial / SG0I) % SG1J;
+
+  /* local read addresses: final offsets a */
+  unsigned int localReadOffsetA = lr0I*VECTOR_WIDTH + sgId*(MT0I+PAD);
+
+  /* local read addresses: final offsets b */
+  unsigned int localReadOffsetB = lr1J*VECTOR_WIDTH + sgId*(MT1J+PAD) + LDS_OFFSET_B;
+
+  /* local read addresses: declare addresses a */
+  __local DATA_TYPE *localReadA;
+
+  /* local read addresses: declare addresses b */
+  __local DATA_TYPE *localReadB;
+
+  /* declare loop num iterations */
+  unsigned int numIterL;
+
+  /* registers for MAC's */
+  DATA_TYPE rC[TT0I*TT1J];
+  rC[0] = SCALAR_ZERO;
+  rC[1] = SCALAR_ZERO;
+  rC[2] = SCALAR_ZERO;
+  rC[3] = SCALAR_ZERO;
+  rC[4] = SCALAR_ZERO;
+  rC[5] = SCALAR_ZERO;
+  rC[6] = SCALAR_ZERO;
+  rC[7] = SCALAR_ZERO;
+  rC[8] = SCALAR_ZERO;
+  rC[9] = SCALAR_ZERO;
+  rC[10] = SCALAR_ZERO;
+  rC[11] = SCALAR_ZERO;
+  rC[12] = SCALAR_ZERO;
+  rC[13] = SCALAR_ZERO;
+  rC[14] = SCALAR_ZERO;
+  rC[15] = SCALAR_ZERO;
+  rC[16] = SCALAR_ZERO;
+  rC[17] = SCALAR_ZERO;
+  rC[18] = SCALAR_ZERO;
+  rC[19] = SCALAR_ZERO;
+  rC[20] = SCALAR_ZERO;
+  rC[21] = SCALAR_ZERO;
+  rC[22] = SCALAR_ZERO;
+  rC[23] = SCALAR_ZERO;
+  rC[24] = SCALAR_ZERO;
+  rC[25] = SCALAR_ZERO;
+  rC[26] = SCALAR_ZERO;
+  rC[27] = SCALAR_ZERO;
+  rC[28] = SCALAR_ZERO;
+  rC[29] = SCALAR_ZERO;
+  rC[30] = SCALAR_ZERO;
+  rC[31] = SCALAR_ZERO;
+  numIterL = sizeL / LOCAL_DEPTHU;
+
+  /* local read addresses: init pointers a */
+  localReadA = (__local DATA_TYPE *)(localMemory + localReadOffsetA);
+
+  /* local read addresses: init pointers b */
+  localReadB = (__local DATA_TYPE *)(localMemory + localReadOffsetB);
+
+  /******************************************/
+  /* Unrolled Loop - Begin                  */
+  /******************************************/
+  while (numIterL-- > 0) {
+
+    /* global read a */
+    a_0_0_0_0 = *(globalReadA_0_0_0_0 + 0);
+    a_0_1_0_0 = *(globalReadA_0_0_0_0 + 1);
+
+    /* global read b */
+    b_0_0_0_0 = *(globalReadB_0_0_0_0 + 0);
+    b_0_1_0_0 = *(globalReadB_0_0_0_0 + 1);
+    b_0_0_1_0 = *(globalReadB_0_0_1_0 + 0);
+    b_0_1_1_0 = *(globalReadB_0_0_1_0 + 1);
+
+    /* global read inc a */
+    globalReadA_0_0_0_0 = (__global DATA_TYPE const *)( ((__global DATA_TYPE const *)globalReadA_0_0_0_0) + globalReadIncAL);
+
+    /* global read inc b */
+    globalReadB_0_0_0_0 = (__global DATA_TYPE const *)( ((__global DATA_TYPE const *)globalReadB_0_0_0_0) + globalReadIncBL);
+    globalReadB_0_0_1_0 = (__global DATA_TYPE const *)( ((__global DATA_TYPE const *)globalReadB_0_0_1_0) + globalReadIncBL);
+    barrier(CLK_LOCAL_MEM_FENCE);
+
+    /* local write a */
+    *(localWriteA_0_0_0_0 + 0) = a_0_0_0_0;
+    *(localWriteA_0_0_0_1 + 0) = a_0_1_0_0;
+
+    /* local write b */
+    *(localWriteB_0_0_0_0 + 0) = b_0_0_0_0;
+    *(localWriteB_0_0_0_0 + 1) = b_0_1_0_0;
+    *(localWriteB_0_0_1_0 + 0) = b_0_0_1_0;
+    *(localWriteB_0_0_1_0 + 1) = b_0_1_1_0;
+    barrier(CLK_LOCAL_MEM_FENCE);
+
+    /* iter 0 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+    rB[2*VECTOR_WIDTH+0] = localReadB[2*SG1J*VECTOR_WIDTH + 0];
+    rB[2*VECTOR_WIDTH+1] = localReadB[2*SG1J*VECTOR_WIDTH + 1];
+    rB[3*VECTOR_WIDTH+0] = localReadB[3*SG1J*VECTOR_WIDTH + 0];
+    rB[3*VECTOR_WIDTH+1] = localReadB[3*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x8
+
+    /* iter 1 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+    rB[2*VECTOR_WIDTH+0] = localReadB[2*SG1J*VECTOR_WIDTH + 0];
+    rB[2*VECTOR_WIDTH+1] = localReadB[2*SG1J*VECTOR_WIDTH + 1];
+    rB[3*VECTOR_WIDTH+0] = localReadB[3*SG1J*VECTOR_WIDTH + 0];
+    rB[3*VECTOR_WIDTH+1] = localReadB[3*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x8
+
+    /* iter 2 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+    rB[2*VECTOR_WIDTH+0] = localReadB[2*SG1J*VECTOR_WIDTH + 0];
+    rB[2*VECTOR_WIDTH+1] = localReadB[2*SG1J*VECTOR_WIDTH + 1];
+    rB[3*VECTOR_WIDTH+0] = localReadB[3*SG1J*VECTOR_WIDTH + 0];
+    rB[3*VECTOR_WIDTH+1] = localReadB[3*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x8
+
+    /* iter 3 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+    rB[2*VECTOR_WIDTH+0] = localReadB[2*SG1J*VECTOR_WIDTH + 0];
+    rB[2*VECTOR_WIDTH+1] = localReadB[2*SG1J*VECTOR_WIDTH + 1];
+    rB[3*VECTOR_WIDTH+0] = localReadB[3*SG1J*VECTOR_WIDTH + 0];
+    rB[3*VECTOR_WIDTH+1] = localReadB[3*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x8
+
+    /* iter 4 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+    rB[2*VECTOR_WIDTH+0] = localReadB[2*SG1J*VECTOR_WIDTH + 0];
+    rB[2*VECTOR_WIDTH+1] = localReadB[2*SG1J*VECTOR_WIDTH + 1];
+    rB[3*VECTOR_WIDTH+0] = localReadB[3*SG1J*VECTOR_WIDTH + 0];
+    rB[3*VECTOR_WIDTH+1] = localReadB[3*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x8
+
+    /* iter 5 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+    rB[2*VECTOR_WIDTH+0] = localReadB[2*SG1J*VECTOR_WIDTH + 0];
+    rB[2*VECTOR_WIDTH+1] = localReadB[2*SG1J*VECTOR_WIDTH + 1];
+    rB[3*VECTOR_WIDTH+0] = localReadB[3*SG1J*VECTOR_WIDTH + 0];
+    rB[3*VECTOR_WIDTH+1] = localReadB[3*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x8
+
+    /* iter 6 */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+    rB[2*VECTOR_WIDTH+0] = localReadB[2*SG1J*VECTOR_WIDTH + 0];
+    rB[2*VECTOR_WIDTH+1] = localReadB[2*SG1J*VECTOR_WIDTH + 1];
+    rB[3*VECTOR_WIDTH+0] = localReadB[3*SG1J*VECTOR_WIDTH + 0];
+    rB[3*VECTOR_WIDTH+1] = localReadB[3*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read increment a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read increment b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x8
+
+    /* iter 7 (last) */
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+    rB[2*VECTOR_WIDTH+0] = localReadB[2*SG1J*VECTOR_WIDTH + 0];
+    rB[2*VECTOR_WIDTH+1] = localReadB[2*SG1J*VECTOR_WIDTH + 1];
+    rB[3*VECTOR_WIDTH+0] = localReadB[3*SG1J*VECTOR_WIDTH + 0];
+    rB[3*VECTOR_WIDTH+1] = localReadB[3*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read init pointers a */
+    localReadA = (__local DATA_TYPE *)(localMemory + localReadOffsetA);
+
+    /* local read init pointers b */
+    localReadB = (__local DATA_TYPE *)(localMemory + localReadOffsetB);
+    MAC_4x8
+
+    /******************************************/
+    /* Unrolled Loop - End                    */
+    /******************************************/
+  }
+
+  /******************************************/
+  /* Tail Loop                              */
+  /******************************************/
+  numIterL = (((sizeL % LOCAL_DEPTHU) + LOCAL_SPLITU - 1) / LOCAL_SPLITU);
+
+  /* global read a */
+  a_0_0_0_0 = ( globalReadOffsetAL_0_0 + 0 >= (sizeL % LOCAL_DEPTHU) ) ? SCALAR_ZERO : *(globalReadA_0_0_0_0 + 0);
+  a_0_1_0_0 = ( globalReadOffsetAL_0_0 + 1 >= (sizeL % LOCAL_DEPTHU) ) ? SCALAR_ZERO : *(globalReadA_0_0_0_0 + 1);
+
+  /* global read b */
+  b_0_0_0_0 = ( globalReadOffsetBL_0_0 + 0 >= (sizeL % LOCAL_DEPTHU) ) ? SCALAR_ZERO : *(globalReadB_0_0_0_0 + 0);
+  b_0_1_0_0 = ( globalReadOffsetBL_0_0 + 0 >= (sizeL % LOCAL_DEPTHU) ) ? SCALAR_ZERO : *(globalReadB_0_0_0_0 + 1);
+  b_0_0_1_0 = ( globalReadOffsetBL_1_0 + 0 >= (sizeL % LOCAL_DEPTHU) ) ? SCALAR_ZERO : *(globalReadB_0_0_1_0 + 0);
+  b_0_1_1_0 = ( globalReadOffsetBL_1_0 + 0 >= (sizeL % LOCAL_DEPTHU) ) ? SCALAR_ZERO : *(globalReadB_0_0_1_0 + 1);
+  barrier(CLK_LOCAL_MEM_FENCE);
+
+  /* local write init pointers a */
+  localWriteA_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_0);
+  localWriteA_0_0_0_1 = (__local DATA_TYPE *)(localMemory + localWriteOffsetA_0_0_0_1);
+
+  /* local write init pointers b */
+  localWriteB_0_0_0_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_0_0);
+  localWriteB_0_0_1_0 = (__local DATA_TYPE *)(localMemory + localWriteOffsetB_0_0_1_0);
+
+  /* local write a */
+  *(localWriteA_0_0_0_0 + 0) = a_0_0_0_0;
+  *(localWriteA_0_0_0_1 + 0) = a_0_1_0_0;
+
+  /* local write b */
+  *(localWriteB_0_0_0_0 + 0) = b_0_0_0_0;
+  *(localWriteB_0_0_0_0 + 1) = b_0_1_0_0;
+  *(localWriteB_0_0_1_0 + 0) = b_0_0_1_0;
+  *(localWriteB_0_0_1_0 + 1) = b_0_1_1_0;
+  barrier(CLK_LOCAL_MEM_FENCE);
+
+  /* tail loop: macs */
+  while (numIterL-- > 0) {
+
+    /* local read a */
+    rA[0*VECTOR_WIDTH+0] = localReadA[0*SG0I*VECTOR_WIDTH + 0];
+    rA[0*VECTOR_WIDTH+1] = localReadA[0*SG0I*VECTOR_WIDTH + 1];
+    rA[1*VECTOR_WIDTH+0] = localReadA[1*SG0I*VECTOR_WIDTH + 0];
+    rA[1*VECTOR_WIDTH+1] = localReadA[1*SG0I*VECTOR_WIDTH + 1];
+
+    /* local read b */
+    rB[0*VECTOR_WIDTH+0] = localReadB[0*SG1J*VECTOR_WIDTH + 0];
+    rB[0*VECTOR_WIDTH+1] = localReadB[0*SG1J*VECTOR_WIDTH + 1];
+    rB[1*VECTOR_WIDTH+0] = localReadB[1*SG1J*VECTOR_WIDTH + 0];
+    rB[1*VECTOR_WIDTH+1] = localReadB[1*SG1J*VECTOR_WIDTH + 1];
+    rB[2*VECTOR_WIDTH+0] = localReadB[2*SG1J*VECTOR_WIDTH + 0];
+    rB[2*VECTOR_WIDTH+1] = localReadB[2*SG1J*VECTOR_WIDTH + 1];
+    rB[3*VECTOR_WIDTH+0] = localReadB[3*SG1J*VECTOR_WIDTH + 0];
+    rB[3*VECTOR_WIDTH+1] = localReadB[3*SG1J*VECTOR_WIDTH + 1];
+
+    /* local read inc a */
+    localReadA += LOCAL_SPLITU*(MT0I+PAD);
+
+    /* local read inc b */
+    localReadB += LOCAL_SPLITU*(MT1J+PAD);
+    MAC_4x8
+  }
+
+  /* shift vector components d1 */
+  unsigned int wgMT1J = size1J - wg1J*MT1J;
+  if (wgMT1J > MT1J) wgMT1J = MT1J;
+  unsigned int r1J = wgMT1J % GLOBAL_LOAD_VECTOR_WIDTH_B;
+  if (r1J > 0 && ((wgMT1J/VECTOR_WIDTH) % SG1J) == (serial / SG0I) % SG1J ) {
+    unsigned int s1J = (wgMT1J%VECTOR_WIDTH)/GLOBAL_LOAD_VECTOR_WIDTH_B + (wgMT1J/(SG1J*VECTOR_WIDTH))*(VECTOR_WIDTH/GLOBAL_LOAD_VECTOR_WIDTH_B);
+    if (r1J == 1) {
+      if (s1J == 0) {
+        rC[0 + 0*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[0 + 0*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+        rC[1 + 0*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[1 + 0*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+        rC[2 + 0*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[2 + 0*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+        rC[3 + 0*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[3 + 0*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+      } else if (s1J == 1) {
+        rC[0 + 1*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[0 + 1*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+        rC[1 + 1*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[1 + 1*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+        rC[2 + 1*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[2 + 1*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+        rC[3 + 1*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[3 + 1*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+      } else if (s1J == 2) {
+        rC[0 + 2*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[0 + 2*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+        rC[1 + 2*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[1 + 2*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+        rC[2 + 2*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[2 + 2*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+        rC[3 + 2*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[3 + 2*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+      } else {
+        rC[0 + 3*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[0 + 3*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+        rC[1 + 3*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[1 + 3*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+        rC[2 + 3*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[2 + 3*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+        rC[3 + 3*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 0*TT0I] = rC[3 + 3*TT0I*GLOBAL_LOAD_VECTOR_WIDTH_B + 1*TT0I];
+      }
+    }
+  }
+
+  /* not-LocalSplitU: global write indices */
+  unsigned int globalC0I = (wg0I)*MT0I + (serial % SG0I)*VECTOR_WIDTH;
+  unsigned int globalC1J = (wg1J)*MT1J + (serial / SG0I)*VECTOR_WIDTH;
+  unsigned int globalCK = (wgK);
+
+  /* not-LocalSplitU: global write */
+  if (globalC0I + 0 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+0 + (0*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 1 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+1 + (0*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 0 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+0 + (0*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 1 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+1 + (0*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 0 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+0 + (0*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 1 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+1 + (0*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 0 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+0 + (0*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 1 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 0*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 0*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+1 + (0*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 0 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+0 + (1*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 1 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+1 + (1*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 0 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+0 + (1*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 1 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+1 + (1*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 0 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+0 + (1*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 1 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+1 + (1*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 0 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+0 + (1*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 1 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 1*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 1*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+1 + (1*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 0 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 2*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 2*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+0 + (2*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 1 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 2*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 2*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+1 + (2*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 0 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 2*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 2*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+0 + (2*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 1 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 2*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 2*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+1 + (2*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 0 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 2*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 2*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+0 + (2*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 1 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 2*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 2*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+1 + (2*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 0 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 2*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 2*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+0 + (2*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 1 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 2*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 2*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+1 + (2*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 0 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 3*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 3*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+0 + (3*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 1 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 3*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 3*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+1 + (3*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 0 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 3*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 3*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+0 + (3*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 1 + 0*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 3*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 0*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 3*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[0*VECTOR_WIDTH+1 + (3*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 0 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 3*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 3*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+0 + (3*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 1 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 0 + 3*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 0 + 3*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+1 + (3*VECTOR_WIDTH+0)*TT0I], beta) } }
+  if (globalC0I + 0 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 3*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 0 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 3*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+0 + (3*VECTOR_WIDTH+1)*TT0I], beta) } }
+  if (globalC0I + 1 + 1*SG0I*VECTOR_WIDTH < size0I) {  if (globalC1J + 1 + 3*SG1J*VECTOR_WIDTH < size1J) {  TYPE_MAC_WRITE( C[ GLOBAL_C( (unsigned long) globalC0I + 1 + 1*SG0I*VECTOR_WIDTH, (unsigned long) globalC1J + 1 + 3*SG1J*VECTOR_WIDTH, (unsigned long) globalCK) ], alpha, rC[1*VECTOR_WIDTH+1 + (3*VECTOR_WIDTH+1)*TT0I], beta) } }
+}
+);
+#endif
--- a/src/library/blas/AutoGemm/UserGemmKernelSources/sgemm_Col_NT_B1_MX032_NX032_KX16_SINGLE_src.cpp
+++ b/src/library/blas/AutoGemm/UserGemmKernelSources/sgemm_Col_NT_B1_MX032_NX032_KX16_SINGLE_src.cpp
@@ -58,7 +58,7 @@
   uint offsetB,
   uint offsetC)
 {
-	float rC[2][2] = { (float)0 };
+	float rC[2][2] = { {(float)0} };
 	float rA[1][2];
 	float rB[1][2];
 
--- a/src/library/blas/AutoGemm/UserGemmKernelSources/sgemm_Col_NT_B1_MX032_NX064_KX16_ROW_src.cpp
+++ b/src/library/blas/AutoGemm/UserGemmKernelSources/sgemm_Col_NT_B1_MX032_NX064_KX16_ROW_src.cpp
@@ -65,7 +65,7 @@
   uint offsetB,
   uint offsetC)
 {
-	float rC[2][4] = { (float)0 };
+	float rC[2][4] = { { (float)0 } };
 	float rA[1][2];
 	float rB[1][4];
 
--- a/src/library/blas/AutoGemm/UserGemmKernelSources/sgemm_Col_NT_B1_MX064_NX032_KX16_COL_src.cpp
+++ b/src/library/blas/AutoGemm/UserGemmKernelSources/sgemm_Col_NT_B1_MX064_NX032_KX16_COL_src.cpp
@@ -64,7 +64,7 @@
   uint offsetB,
   uint offsetC)
 {
-	float rC[4][2] = { (float)0 };
+	float rC[4][2] = { { (float)0 } };
 	float rA[1][4];
 	float rB[1][2];
 
--- a/src/library/blas/AutoGemm/UserGemmKernelSources/sgemm_Col_NT_B1_MX128_NX128_KX16_src.cpp
+++ b/src/library/blas/AutoGemm/UserGemmKernelSources/sgemm_Col_NT_B1_MX128_NX128_KX16_src.cpp
@@ -129,7 +129,7 @@
 uint offsetB,
 uint offsetC)
 {
-	float rC[8][8] = { (float)0 };
+	float rC[8][8] = { { (float)0 } };
 	float rA[1][8];
 	float rB[1][8];
 
--- a/src/library/blas/generic/common.c
+++ b/src/library/blas/generic/common.c
@@ -537,11 +537,13 @@
     identifyDevice(&target);
     opts[0] = '\0';
 
-#if !defined NDEBUG
-    // Nvidia runtime does not appear to support the -g flag, at least in their OpenCL v1.1 runtime
-    if( target.ident.vendor != VENDOR_NVIDIA )
-        addBuildOpt( opts, BUILD_OPTS_MAXLEN, "-g" );
-#endif  /* NDEBUG */
+
+// clBuildProgram is crashing in xTRMM with the '-g' debug flag
+//#if !defined NDEBUG
+//    // Nvidia runtime does not appear to support the -g flag, at least in their OpenCL v1.1 runtime
+//    if( target.ident.vendor != VENDOR_NVIDIA )
+//        addBuildOpt( opts, BUILD_OPTS_MAXLEN, "-g" );
+//#endif  /* NDEBUG */
 
     if (target.ident.vendor == VENDOR_NVIDIA &&
         !strcmp(mempat->name, "2-staged cached global memory based "
--- a/src/library/blas/generic/solution_seq.c
+++ b/src/library/blas/generic/solution_seq.c
@@ -238,7 +238,7 @@
 {
     int i;
     cl_mem *imgs = step->args.scimage;
-    cl_device_id devID = NULL;;
+    cl_device_id devID = NULL;
 
     for (i = 0; (i < 2) && (imgs[i] != NULL); i++) {
         if (devID == NULL) {
--- a/src/library/blas/gens/clTemplates/dot.cl
+++ b/src/library/blas/gens/clTemplates/dot.cl
@@ -30,7 +30,7 @@
 {
 	__global %TYPE *X = _X + offx;
 	__global %TYPE *Y = _Y + offy;
-    %TYPE dotP = (%TYPE) 0.0;
+    %TYPE dotP = (%TYPE) 0;
 
     if ( incx < 0 ) {
         X = X + (N - 1) * abs(incx);
--- a/src/library/blas/gens/clTemplates/gbmv.cl
+++ b/src/library/blas/gens/clTemplates/gbmv.cl
@@ -106,7 +106,7 @@
                         %CONJUGATE(1 , reg1);
                     #endif
                     #ifdef HBMV_ONLY
-                        reg1.odd = 0.0;                 // Imaginary part of diagonal is assumed to be zero
+                        reg1.odd = 0;                 // Imaginary part of diagonal is assumed to be zero
                     #endif
                     %MAD( sum, reg1, reg2 );
                 #else
@@ -179,7 +179,7 @@
 
 #define TARGET_ROWS  ( %DEF_TARGET_ROWS )
 #define HEIGHT ( %DEF_H)
-#pragma OPENCL EXTENSION cl_amd_printf : enable
+//#pragma OPENCL EXTENSION cl_amd_printf : enable
 __kernel void %PREFIXgbmv_RT_kernel( __global const %TYPE * _A, __global %TYPE * _y_vector, __global %TYPE const* restrict _x_vector,
                                     uint M, uint N, uint KL, uint KU, uint lda, int incx, int incy, uint offa, uint offx, uint offy
 #ifndef TBMV_ONLY
--- a/src/library/blas/gens/clTemplates/her2.cl
+++ b/src/library/blas/gens/clTemplates/her2.cl
@@ -47,7 +47,7 @@
 	__local %TYPE xSharedConj[%TARGET_ROWS];
 	__local %TYPE ySharedConj[%TARGET_ROWS];
 
-	if( (alpha.even == 0.0) && (alpha.odd == 0.0) )
+	if( (alpha.even == 0) && (alpha.odd == 0) )
 		return;
 
 	int nBlocks = ((N - 1) / %TARGET_ROWS) + 1;
@@ -155,7 +155,7 @@
             %ADD( res2, res1, res4 );
  /* HER2 defn: On output, if alpha not equal to 0.0, then imaginary part of A is set to zero. */
 
-			res2.odd = (r == c) ? 0.0 : res2.odd;
+			res2.odd = (r == c) ? 0 : res2.odd;
 
 
 			A[r + c * lda] = res2;
@@ -369,7 +369,7 @@
     __local %TYPE xSharedConj[%TARGET_ROWS];
     __local %TYPE ySharedConj[%TARGET_ROWS];
 
-	if( (alpha.even == 0.0) && (alpha.odd == 0.0) )
+	if( (alpha.even == 0) && (alpha.odd == 0) )
 		return;
 
     int nBlocks = ((N - 1) / %TARGET_ROWS) + 1;
@@ -478,7 +478,7 @@
             %ADD( res2, res1, res4 );
  /* HER2 defn: On output, if alpha not equal to 0.0, then imaginary part of A is set to zero. */
 
-			res2.odd = (r == c) ? 0.0 : res2.odd;
+			res2.odd = (r == c) ? 0 : res2.odd;
 
 
 			A[r + c * lda] = res2;
--- a/src/library/blas/gens/clTemplates/iamax.cl
+++ b/src/library/blas/gens/clTemplates/iamax.cl
@@ -15,7 +15,7 @@
  * ************************************************************************/
 
 static const char *iamax_kernel = "
-#pragma OPENCL EXTENSION cl_amd_printf:enable
+//#pragma OPENCL EXTENSION cl_amd_printf:enable
 #ifdef DOUBLE_PRECISION
     #ifdef cl_khr_fp64
     #pragma OPENCL EXTENSION cl_khr_fp64 : enable
--- a/src/library/blas/gens/clTemplates/reduction.cl
+++ b/src/library/blas/gens/clTemplates/reduction.cl
@@ -30,7 +30,7 @@
 {
  	__global %TYPE *X = _X + offx;
     __global %TYPE *res = _res + offRes;
-    %TYPE redVal = (%TYPE) 0.0;
+    %TYPE redVal = (%TYPE) 0;
 
     int gOffset;
     for( gOffset=(get_global_id(0) * %V); (gOffset + %V - 1)<N; gOffset+=( get_global_size(0) * %V ) )
@@ -234,7 +234,7 @@
 {
  	__global %TYPE *X = _X + offx;
     __global %TYPE *res = _res + offRes;
-    %TYPE redVal = (%TYPE) 0.0;
+    %TYPE redVal = (%TYPE) 0;
 
     int gOffset;
     for( gOffset=(get_global_id(0) * %V); (gOffset + %V - 1)<N; gOffset+=( get_global_size(0) * %V ) )
@@ -272,7 +272,7 @@
     #define MAX 0x1.fffffep127f             // Max in case of s/c
 #endif
 
-#define ZERO (%TYPE)0.0
+#define ZERO (%TYPE)0
 
 // Since scale & ssq are always of primitive type,
 // This kernel will always be called only for float/double
@@ -314,7 +314,7 @@
     // Now we calculate ssq by loading the array again and dividing the
     // elements by scale and squaring it.
 
-    %TYPE ssq = (%TYPE) 0.0;
+    %TYPE ssq = (%TYPE) 0;
     %TYPE scaleOfWG = _scaleOfWG;
 
     // If scale was zero, that means the whole array encountered before was filled with zeroes
--- a/src/library/blas/gens/clTemplates/rotg.cl
+++ b/src/library/blas/gens/clTemplates/rotg.cl
@@ -25,8 +25,8 @@
     #endif
 #endif
 
-#define ZERO (%TYPE)0.0
-#define PZERO (%PTYPE)0.0
+#define ZERO (%TYPE)(0)
+#define PZERO (%PTYPE)(0)
 
 // CABS(A) returns SQRT(REALPART(A)**2+IMAGPART(A)**2) -- opencl function length() computes the same
 #define CABS( arg )  length( arg )
@@ -53,7 +53,7 @@
 
 	        if(isequal(scale, ZERO))
 	        {
-	            Creg = 1.0;
+	            Creg = 1;
 	            Sreg = ZERO;
 	            R = ZERO;
 	            Z = ZERO;
@@ -68,7 +68,7 @@
 	            Creg = Areg / R;
 	            Sreg = Breg / R;
 	            Z = (isgreater(absA, absB))? Sreg:
-	                    ( (isnotequal(Creg, ZERO))? (1.0/Creg): 1.0 );
+	                    ( (isnotequal(Creg, ZERO))? (1/Creg): 1 );
 	        }
 	        _A[offa] = R;
 	        _B[offb] = Z;
@@ -84,7 +84,7 @@
 	        if(isequal(cabsA, PZERO))
 	        {
 	            Creg = PZERO;
-	            Sreg = (%TYPE)(1.0, 0.0);
+	            Sreg = (%TYPE)(1, 0);
 	            Areg = Breg;
 	        }
 	        else
--- a/src/library/blas/gens/clTemplates/rotm.cl
+++ b/src/library/blas/gens/clTemplates/rotm.cl
@@ -25,9 +25,9 @@
     #endif
 #endif
 
-#define ZERO    (%TYPE)0.0
-#define ONE     (%TYPE)1.0
-#define TWO     (%TYPE)2.0
+#define ZERO    (%TYPE)(0)
+#define ONE     (%TYPE)(1)
+#define TWO     (%TYPE)(2)
 
 __kernel void %PREFIXrotm_kernel( __global %TYPE *_X, __global %TYPE *_Y, uint N,
                                 uint offx, int incx, uint offy, int incy
--- a/src/library/blas/gens/clTemplates/rotmg.cl
+++ b/src/library/blas/gens/clTemplates/rotmg.cl
@@ -26,13 +26,13 @@
 #endif
 
 // Rotmg exists only for S/D
-#define ZERO    (%TYPE)0.0
-#define ONE     (%TYPE)1.0
-#define TWO     (%TYPE)2.0
+#define ZERO    (%TYPE)(0)
+#define ONE     (%TYPE)(1)
+#define TWO     (%TYPE)(2)
 
-#define GAM     (%TYPE)4096.0
+#define GAM     (%TYPE)(4096)
 #define GAMSQ   (%TYPE)( GAM * GAM )
-#define RGAMSQ  (%TYPE)( 1.0 / GAMSQ )
+#define RGAMSQ  (%TYPE)( 1 / GAMSQ )
 
 __kernel void %PREFIXrotmg_kernel( __global %TYPE *_D1, __global %TYPE *_D2, __global %TYPE *_X1,
                                 __global %TYPE *_Y1, __global %TYPE *_param,
--- a/src/library/blas/gens/clTemplates/syr_her.cl
+++ b/src/library/blas/gens/clTemplates/syr_her.cl
@@ -45,7 +45,7 @@
 	__local %TYPE yShared[%TARGET_ROWS];
 
 	// If alpha is zero, the computation yields to a zero value and therefore doesnot update the A matrix.
-	if(alpha == 0.0)
+	if(alpha == 0)
 		return;
 
 	A = _A + offa;
@@ -140,7 +140,7 @@
 			      these values. On output, the imaginary parts of diagonal elements are set to zero.
 				*/
 
-				res.odd = (r == c) ? 0.0 : res.odd;
+				res.odd = (r == c) ? 0 : res.odd;
 			#endif
 
 			A( r, c ) = res;
@@ -325,7 +325,7 @@
 	__local %TYPE yShared[%TARGET_ROWS];
 
 	// If alpha is zero, the computation yields to a zero value and therefore doesnot update the A matrix.
-	if(alpha == 0.0)
+	if(alpha == 0)
 		return;
 
 	A = _A + offa;
@@ -419,7 +419,7 @@
 			      these values. On output, the imaginary parts of diagonal elements are set to zero.
 				*/
 
-				res.odd = (r == c) ? 0.0 : res.odd;
+				res.odd = (r == c) ? 0 : res.odd;
 			#endif
 
 			A( r , c ) = res;
--- a/src/library/blas/gens/clTemplates/trsv.cl
+++ b/src/library/blas/gens/clTemplates/trsv.cl
@@ -134,7 +134,7 @@
 #else
     #define A(row, col) A[ (row) + (col) * lda]
 #endif
-#pragma OPENCL EXTENSION cl_amd_printf : enable
+//#pragma OPENCL EXTENSION cl_amd_printf : enable
 // Only one block of threads launched
 __kernel void %PREFIXtrsv_CL_SolveTriangle_kernel( __global const %TYPE* _A, __global %TYPE* _xnew, uint N, int incx, int isUnity,
                                                    uint lda, int doConj, int startCol, int endRow, uint offa, uint offx
@@ -240,7 +240,7 @@
 #else
     #define A( row, col) A[ (row) + (col) * lda]
 #endif
-#pragma OPENCL EXTENSION cl_amd_printf : enable
+//#pragma OPENCL EXTENSION cl_amd_printf : enable
 __kernel void %PREFIXtrsv_CUT_SolveTriangle_kernel(     __global const %TYPE* _A,
                                                 __global %TYPE* _xnew,
                                                 uint N,
@@ -342,7 +342,7 @@
 #else
     #define A(row, col) A[ (row) + (col) * lda]
 #endif
-#pragma OPENCL EXTENSION cl_amd_printf : enable
+//#pragma OPENCL EXTENSION cl_amd_printf : enable
 
 // Column-Major Lower Non-Unity case
 // StartRow points to actual Row to start from( absolute Column number)
--- a/src/library/blas/gens/clTemplates/trsv_gemv.cl
+++ b/src/library/blas/gens/clTemplates/trsv_gemv.cl
@@ -1420,7 +1420,8 @@
 	int blkid = get_group_id(0);
 	int V= %V;
 
-	__local %TYPE solved[%TRIANGLE_HEIGHT];
+	__local %TYPE%V solvedV[%TRIANGLE_HEIGHT/%V];
+	__local %TYPE *solved = (__local %TYPE *)solvedV;
 	__local %TYPE reduce[%TARGET_HEIGHT][ %BLOCKSIZE / %TARGET_HEIGHT];
 	__local %TYPE%V *solved_vec;
 	int blockStartRow;
--- a/src/library/blas/gens/trsm.c
+++ b/src/library/blas/gens/trsm.c
@@ -1156,7 +1156,7 @@
         return -ENOMEM;
     }
 
-    kgenAddStmt(ctx, "#pragma OPENCL EXTENSION cl_amd_printf : enable\n\n");
+    // kgenAddStmt(ctx, "#pragma OPENCL EXTENSION cl_amd_printf : enable\n\n");
 
     b = isDoubleBasedType(dtype);
     kgenDeclareUptrs(ctx, b);
--- a/src/library/blas/ixamax.c
+++ b/src/library/blas/ixamax.c
@@ -43,7 +43,7 @@
         cl_int err;
 		ListHead seq, seq2;
         clblasStatus retCode = clblasSuccess;
-        cl_event firstiAmaxCall;
+        cl_event firstiAmaxCall = NULL;
         CLBlasKargs redctnArgs;
         ListNode *listNodePtr;
         SolutionStep *step;
@@ -150,6 +150,7 @@
                     err = executeSolutionSeq(&seq2);
                 }
                 freeSolutionSeq(&seq2);
+                clReleaseEvent(firstiAmaxCall);
             }
 		}
 
--- a/src/library/blas/specialCases/GemmSpecialCases.cpp
+++ b/src/library/blas/specialCases/GemmSpecialCases.cpp
@@ -14,6 +14,8 @@
 * limitations under the License.
 * ************************************************************************/
 
+#include <algorithm>
+
 #include "GemmSpecialCases.h"
 #include "UserGemmKernelSources/UserGemmKernelSourceIncludes.h"
 #include "UserGemmKernelSources/UserGemmClKernels.h"
@@ -399,6 +401,329 @@
 	return clblasNotImplemented;
 }
 
+#define CL_DEVICE_GFXIP_MAJOR_AMD 0x404A
+#define CL_DEVICE_GFXIP_MINOR_AMD 0x404B
+#define GFXIP_MAJOR_VEGA 9
+#define GFXIP_MINOR_VEGA_20 6
+
+clblasStatus DGEMM_tensile(
+	clblasOrder order,
+	clblasTranspose transA,
+	clblasTranspose transB,
+	cl_uint M, cl_uint N, cl_uint K,
+	double alpha,
+	cl_mem A, cl_uint offA, cl_uint lda,
+	cl_mem B, cl_uint offB, cl_uint ldb,
+	double beta,
+	cl_mem C, cl_uint offC, cl_uint ldc,
+	cl_uint numCommandQueues,
+	cl_command_queue *commandQueues,
+	cl_uint numEventsInWaitList,
+	const cl_event *eventWaitList,
+	cl_event *events,
+	bool &specialCaseHandled)
+{
+	const char *kernelSource = NULL;
+	cl_kernel  *clKernel = NULL;
+	const unsigned char *kernelBinary = NULL;
+	size_t kernelBinarySize = 0;
+
+	cl_int err;
+
+	// query device
+	cl_device_id device;
+	err = clGetCommandQueueInfo(commandQueues[0], CL_QUEUE_DEVICE, sizeof(device), &device, NULL);
+	CL_CHECK(err);
+
+	cl_uint gfxipMajor = 0;
+	err = clGetDeviceInfo(device, CL_DEVICE_GFXIP_MAJOR_AMD, sizeof(gfxipMajor), &gfxipMajor, NULL);
+	CL_CHECK(err);
+
+	cl_uint gfxipMinor = 0;
+	err = clGetDeviceInfo(device, CL_DEVICE_GFXIP_MINOR_AMD, sizeof(gfxipMinor), &gfxipMinor, NULL);
+	CL_CHECK(err);
+
+	if (gfxipMajor == GFXIP_MAJOR_VEGA && gfxipMinor == GFXIP_MINOR_VEGA_20)
+	{
+		int M_divisible_by_64 = (M % 64) ? 0 : 1; // M is divisible by 64
+		int N_divisible_by_64 = (N % 64) ? 0 : 1; // N is divisible by 64
+		int K_divisible_by_64 = (K % 64) ? 0 : 1; // K is divisible by 64
+		int mask = (M_divisible_by_64 << 2) | (N_divisible_by_64 << 1) | (K_divisible_by_64 << 0); // 3bit divisibility mask
+
+		enum
+		{
+			NONE,   // none of M,N,K is divisible by 64
+			K64,    // only K is divisible by 64
+			N64,    // only N is divisible by 64
+			NK64,   // N and K are both divisible, and M is not divisible by 64
+			M64,    // only M is divisible by 64
+			MK64,   // M and K are both divisible, and N is not divisible by 64
+			MN64,   // M and N are both divisible, and K is not divisible by 64
+			MNK64,  // all of M,N,K are divisible by 64
+		};
+
+		assert(mask >= NONE && mask <= MNK64);
+
+		// decide if we execute Tensile kernel or fallback to original clBLAS implementation
+		bool fallback = false;
+		if (order == clblasRowMajor)
+		{
+			if (transA == clblasNoTrans && transB == clblasNoTrans)
+			{
+				switch (mask)
+				{
+				case NONE : break;
+				case K64  : break;
+				case N64  : break;
+				case NK64 : fallback = true; break;
+				case M64  : break;
+				case MK64 : fallback = (M > 1280) || (K < 128) || (M + N < 1150) || (M + N > 4574) || (M + K > 7168) || (M + N + K < 1424) || (M + N + K > 8338); break;
+				case MN64 : break;
+				case MNK64: fallback = true; break;
+				}
+			}
+			else if (transA == clblasNoTrans && transB == clblasTrans)
+			{
+				switch (mask)
+				{
+				case NONE : break;
+				case K64  : break;
+				case N64  : break;
+				case NK64 : fallback = (K < 128) || (M + N + K < 1040); break;
+				case M64  : break;
+				case MK64 : break;
+				case MN64 : break;
+				case MNK64: fallback = true; break;
+				}
+			}
+			else if (transA == clblasTrans && transB == clblasNoTrans)
+			{
+				switch (mask)
+				{
+				case NONE : break;
+				case K64  : break;
+				case N64  : break;
+				case NK64 : fallback = (M + N > 4987) || (M + N + K > 10176); break;
+				case M64  : fallback = (M > 3072) || (M + N > 4539) || (M + K > 6500) || (M + N + K > 8077); break;
+				case MK64 : fallback = (M > 128) || (N > 894) || (K < 256) || (M + N > 1680) || (M + K > 2112) || (N + K > 3376) || (M + N + K > 3606); break;
+				case MN64 : fallback = (M + N > 3840) || (M + N + K > 7076); break;
+				case MNK64: fallback = (M > 64) || (N > 64) || (K < 768) || (K > 2048) || (M + N > 640) || (M + K > 1408) || (N + K > 1152) || (M + N + K < 576) || (M + N + K > 2048); break;
+				}
+			}
+			else // (transA == clblasTrans && transB == clblasTrans)
+			{
+				switch (mask)
+				{
+				case NONE : break;
+				case K64  : break;
+				case N64  : break;
+				case NK64 : fallback = (M > 3340) || (N < 128) || (N > 2560) || (K < 1536) || (M + N < 1558) || (M + N > 3888) || (M + K < 790) || (N + K < 1536) || (M + N + K < 2639); break;
+				case M64  : break;
+				case MK64 : fallback = (M < 128) || (K < 128) || (M + N < 1558) || (N + K < 1022) || (M + N + K < 2326); break;
+				case MN64 : break;
+				case MNK64: fallback = true; break;
+				}
+			}
+		}
+		else // (order == clblasColumnMajor)
+		{
+			if (transA == clblasNoTrans && transB == clblasNoTrans)
+			{
+				switch (mask)
+				{
+				case NONE : break;
+				case K64  : break;
+				case N64  : break;
+				case NK64 : fallback = (N > 2048) || (M + N < 1168) || ( M + N > 4731) ||(M + N + K < 1534) || (M + N + K > 8635);break;
+				case M64  : break;
+				case MK64 : fallback = true; break;
+				case MN64 : break;
+				case MNK64: fallback = true; break;
+				}
+			}
+			else if (transA == clblasNoTrans && transB == clblasTrans)
+			{
+				switch (mask)
+				{
+				case NONE : break;
+				case K64  : break;
+				case N64  : fallback = (N > 3072) || (M + N > 4539) || (N + K > 6500) || (M + N + K > 8077); break;
+				case NK64 : fallback = (M > 894) || (N > 128) || (M + N > 1814) || (M + K > 3454) || (N + K > 2112) || (M + N + K > 3696); break;
+				case M64  : break;
+				case MK64 : fallback = (M + N > 4987) || (M + N + K > 9996); break;
+				case MN64 : fallback = (M + N > 4160) || (M + N + K > 7076); break;
+				case MNK64: fallback = true; break;
+				}
+			}
+			else if (transA == clblasTrans && transB == clblasNoTrans)
+			{
+				switch (mask)
+				{
+				case NONE : break;
+				case K64  : break;
+				case N64  : break;
+				case NK64 : fallback = (M + N + K < 854); break;
+				case M64  : break;
+				case MK64 : break;
+				case MN64 : break;
+				case MNK64: fallback = true; break;
+				}
+			}
+			else // (transA == clblasTrans && transB == clblasTrans)
+			{
+				switch (mask)
+				{
+				case NONE : break;
+				case K64  : break;
+				case N64  : break;
+				case NK64 : fallback = (N < 128) || (M + N < 1615) || (M + K < 790) || (N + K < 384) || (M + N + K < 2383); break;
+				case M64  : break;
+				case MK64 : fallback = (M < 128) || (N > 3474) || (K < 1280) || (M + N < 1615) || (M + N > 3966) || (M + K < 1536) || (N + K < 1046) || (M + N + K < 2686); break;
+				case MN64 : break;
+				case MNK64: fallback = true; break;
+				}
+			}
+		}
+
+		if (fallback)
+			return clblasNotImplemented;
+
+		// pick kernel
+		cl_uint threadTile[2] = { 4, 4 };
+		cl_uint groupSize[2] = { 8, 8 };
+		if (transA == clblasNoTrans && transB == clblasNoTrans)
+		{
+			kernelSource     =  dgemm_NN_gfx906_tensile_src;
+			clKernel         = &dgemm_NN_gfx906_tensile_clKernel;
+			kernelBinary     =  dgemm_NN_gfx906_tensile_bin;
+			kernelBinarySize =  dgemm_NN_gfx906_tensile_binSize;
+
+			threadTile[0] = dgemm_NN_gfx906_tensile_microTileNumRows;
+			threadTile[1] = dgemm_NN_gfx906_tensile_microTileNumCols;
+			groupSize[0]  = dgemm_NN_gfx906_tensile_workGroupNumRows;
+			groupSize[1]  = dgemm_NN_gfx906_tensile_workGroupNumCols;
+		}
+		else if (transA == clblasNoTrans && transB == clblasTrans)
+		{
+			kernelSource     =  dgemm_NT_gfx906_tensile_src;
+			clKernel         = &dgemm_NT_gfx906_tensile_clKernel;
+			kernelBinary     =  dgemm_NT_gfx906_tensile_bin;
+			kernelBinarySize =  dgemm_NT_gfx906_tensile_binSize;
+
+			threadTile[0] = dgemm_NT_gfx906_tensile_microTileNumRows;
+			threadTile[1] = dgemm_NT_gfx906_tensile_microTileNumCols;
+			groupSize[0]  = dgemm_NT_gfx906_tensile_workGroupNumRows;
+			groupSize[1]  = dgemm_NT_gfx906_tensile_workGroupNumCols;
+		}
+		else if (transA == clblasTrans && transB == clblasNoTrans)
+		{
+			kernelSource     =  dgemm_TN_gfx906_tensile_src;
+			clKernel         = &dgemm_TN_gfx906_tensile_clKernel;
+			kernelBinary     =  dgemm_TN_gfx906_tensile_bin;
+			kernelBinarySize =  dgemm_TN_gfx906_tensile_binSize;
+
+			threadTile[0] = dgemm_TN_gfx906_tensile_microTileNumRows;
+			threadTile[1] = dgemm_TN_gfx906_tensile_microTileNumCols;
+			groupSize[0]  = dgemm_TN_gfx906_tensile_workGroupNumRows;
+			groupSize[1]  = dgemm_TN_gfx906_tensile_workGroupNumCols;
+		}
+		else // (transA == clblasTrans && transB == clblasTrans)
+		{
+			kernelSource     =  dgemm_TT_gfx906_tensile_src;
+			clKernel         = &dgemm_TT_gfx906_tensile_clKernel;
+			kernelBinary     =  dgemm_TT_gfx906_tensile_bin;
+			kernelBinarySize =  dgemm_TT_gfx906_tensile_binSize;
+
+			threadTile[0] = dgemm_TT_gfx906_tensile_microTileNumRows;
+			threadTile[1] = dgemm_TT_gfx906_tensile_microTileNumCols;
+			groupSize[0]  = dgemm_TT_gfx906_tensile_workGroupNumRows;
+			groupSize[1]  = dgemm_TT_gfx906_tensile_workGroupNumCols;
+		}
+
+		specialCaseHandled = true;
+		makeGemmKernel(clKernel, commandQueues[0], kernelSource, User_srcBuildOptions, &kernelBinary, &kernelBinarySize, User_binBuildOptions);
+
+		// convert clBLAS args to Tensile args
+		cl_uint sizeI = M;
+		cl_uint sizeJ = N;
+		cl_uint sizeK = 1;
+		cl_uint sizeL = K;
+
+		cl_uint strideC1 = std::max(sizeI, ldc);
+		cl_uint strideC2 = strideC1 * sizeJ;
+
+		cl_uint strideA1 = std::max(transA == clblasNoTrans ? sizeI : sizeL, lda);
+		cl_uint strideA2 = strideA1 * (transA == clblasNoTrans ? sizeL : sizeJ);
+
+		cl_uint strideB1 = std::max(transB == clblasNoTrans ? sizeL : sizeJ, ldb);
+		cl_uint strideB2 = strideB1 * (transB == clblasNoTrans ? sizeJ : sizeL);
+
+		// grid sizes
+		const cl_uint workDim = 3;
+		size_t localWorkSize[3] = { 256, 1, 1 };
+		size_t globalWorkSize[3];
+		globalWorkSize[2] = 1 * sizeK;
+		cl_uint macroTile0 = groupSize[0] * threadTile[0];
+		cl_uint macroTile1 = groupSize[1] * threadTile[1];
+		cl_uint totalWorkGroups0 = sizeI / macroTile0;
+		cl_uint totalWorkGroups1 = sizeJ / macroTile1;
+
+		// b/c single kernel, add extra work-group here if edge needed
+		if (totalWorkGroups0*macroTile0 < sizeI)
+			totalWorkGroups0++;
+		if (totalWorkGroups1*macroTile1 < sizeJ)
+			totalWorkGroups1++;
+		globalWorkSize[0] = totalWorkGroups0*localWorkSize[0];
+		globalWorkSize[1] = totalWorkGroups1*localWorkSize[1];
+
+		// setup args
+		err = clSetKernelArg(*clKernel,  0, sizeof(C), &C);
+		CL_CHECK(err);
+		err = clSetKernelArg(*clKernel,  1, sizeof(A), &A);
+		CL_CHECK(err);
+		err = clSetKernelArg(*clKernel,  2, sizeof(B), &B);
+		CL_CHECK(err);
+		err = clSetKernelArg(*clKernel,  3, sizeof(alpha), &alpha);
+		CL_CHECK(err);
+		err = clSetKernelArg(*clKernel,  4, sizeof(beta),  &beta);
+		CL_CHECK(err);
+		err = clSetKernelArg(*clKernel,  5, sizeof(offC), &offC);
+		CL_CHECK(err);
+		err = clSetKernelArg(*clKernel,  6, sizeof(offA), &offA);
+		CL_CHECK(err);
+		err = clSetKernelArg(*clKernel,  7, sizeof(offB), &offB);
+		CL_CHECK(err);
+		err = clSetKernelArg(*clKernel,  8, sizeof(strideC1), &strideC1);
+		CL_CHECK(err);
+		err = clSetKernelArg(*clKernel,  9, sizeof(strideC2), &strideC2);
+		CL_CHECK(err);
+		err = clSetKernelArg(*clKernel, 10, sizeof(strideA1), &strideA1);
+		CL_CHECK(err);
+		err = clSetKernelArg(*clKernel, 11, sizeof(strideA2), &strideA2);
+		CL_CHECK(err);
+		err = clSetKernelArg(*clKernel, 12, sizeof(strideB1), &strideB1);
+		CL_CHECK(err);
+		err = clSetKernelArg(*clKernel, 13, sizeof(strideB2), &strideB2);
+		CL_CHECK(err);
+		err = clSetKernelArg(*clKernel, 14, sizeof(sizeI), &sizeI);
+		CL_CHECK(err);
+		err = clSetKernelArg(*clKernel, 15, sizeof(sizeJ), &sizeJ);
+		CL_CHECK(err);
+		err = clSetKernelArg(*clKernel, 16, sizeof(sizeK), &sizeK);
+		CL_CHECK(err);
+		err = clSetKernelArg(*clKernel, 17, sizeof(sizeL), &sizeL);
+		CL_CHECK(err);
+
+		err = clEnqueueNDRangeKernel(commandQueues[0], *clKernel, workDim, NULL, globalWorkSize, localWorkSize, numEventsInWaitList, eventWaitList, &events[0] );
+		CL_CHECK(err);
+		if (err == CL_SUCCESS)
+		{
+			return clblasSuccess;
+		}
+	}
+
+	return clblasNotImplemented;
+}
 
 clblasStatus SGEMM_SPLIT64_32(
 	clblasTranspose transA,
@@ -925,11 +1250,30 @@
 cl_event *events,
 bool &specialCaseHandled)
 {
+	clblasStatus status;
+
+	// handle specific hardware
+	status = DGEMM_tensile(order,
+		transA,
+		transB,
+		M, N, K,
+		alpha,
+		A, offA, lda,
+		B, offB, ldb,
+		beta,
+		C, offC, ldc,
+		numCommandQueues,
+		commandQueues,
+		numEventsInWaitList,
+		eventWaitList,
+		events,
+		specialCaseHandled);
+	if (specialCaseHandled)
+		return status;
+
 	if (order == clblasRowMajor)
 		return clblasNotImplemented;
 
-	clblasStatus status;
-	
 	status = DGEMM_BIG_MOD48(transA,
 		transB,
 		M, N, K,
@@ -991,4 +1335,4 @@
 bool &specialCaseHandled)
 {
 	return clblasNotImplemented;
-}
\ No newline at end of file
+}
--- a/src/library/blas/xasum.c
+++ b/src/library/blas/xasum.c
@@ -43,7 +43,7 @@
         cl_int err;
 		ListHead seq, seq2;
         clblasStatus retCode = clblasSuccess;
-        cl_event firstAsumCall;
+        cl_event firstAsumCall = NULL;
         CLBlasKargs redctnArgs;
         ListNode *listNodePtr;
         SolutionStep *step;
@@ -147,6 +147,7 @@
                     err = executeSolutionSeq(&seq2);
                 }
                 freeSolutionSeq(&seq2);
+                clReleaseEvent(firstAsumCall);
             }
 		}
 
--- a/src/library/blas/xdot.c
+++ b/src/library/blas/xdot.c
@@ -47,7 +47,7 @@
         cl_int err;
 		ListHead seq, seq2;
         clblasStatus retCode = clblasSuccess;
-        cl_event firstDotCall;
+        cl_event firstDotCall = NULL;
         CLBlasKargs redctnArgs;
         ListNode *listNodePtr;
         SolutionStep *step;
@@ -140,22 +140,23 @@
             err = executeSolutionSeq(&seq);
             if (err == CL_SUCCESS)
             {
-            listNodePtr = listNodeFirst(&seq);        // Get the node
-            step = container_of(listNodePtr, node, SolutionStep);
+                listNodePtr = listNodeFirst(&seq);        // Get the node
+                step = container_of(listNodePtr, node, SolutionStep);
 
-                redctnArgs.N = step->pgran.numWGSpawned[0];     // 1D block was used
+                    redctnArgs.N = step->pgran.numWGSpawned[0];     // 1D block was used
 
                 listInitHead(&seq2);
-            err = makeSolutionSeq(CLBLAS_REDUCTION_EPILOGUE, &redctnArgs, numCommandQueues, commandQueues,
-                           1, &firstDotCall, events, &seq2);
+                err = makeSolutionSeq(CLBLAS_REDUCTION_EPILOGUE, &redctnArgs, numCommandQueues, commandQueues,
+                               1, &firstDotCall, events, &seq2);
 
-            if (err == CL_SUCCESS)
-            {
-                    err = executeSolutionSeq(&seq2);
-            }
+                if (err == CL_SUCCESS)
+                {
+                        err = executeSolutionSeq(&seq2);
+                }
                 freeSolutionSeq(&seq2);
-		}
-		}
+                clReleaseEvent(firstDotCall);
+            }
+        }
 
 		freeSolutionSeq(&seq);
 		return (clblasStatus)err;
--- a/src/library/blas/xgemm.cc
+++ b/src/library/blas/xgemm.cc
@@ -241,7 +241,6 @@
         clProgram,
         1, &clDevice,
         sourceBuildOptions, NULL, NULL );
-      CL_CHECK(err)
     }
 
     // print build failure
--- a/src/library/blas/xhemv.c
+++ b/src/library/blas/xhemv.c
@@ -45,7 +45,7 @@
 {
     cl_int err;
     ListHead seq1, seq2;
-	cl_event first_event;
+	cl_event first_event = NULL;
     clblasStatus retCode = clblasSuccess;
 
     if (!clblasInitialized) {
@@ -110,7 +110,8 @@
 				err = executeSolutionSeq(&seq2);
 			}
 			freeSolutionSeq(&seq2);
-		}
+            clReleaseEvent(first_event);
+        }
     }
 
     freeSolutionSeq(&seq1);
--- a/src/library/blas/xher2k.c
+++ b/src/library/blas/xher2k.c
@@ -53,7 +53,7 @@
     clblasStatus err;
     clblasUplo fUplo;
     clblasTranspose fTransA;
-    cl_event firstHerkCall;
+    cl_event firstHerkCall = NULL;
     clblasStatus retCode = clblasSuccess;
 
     if (!clblasInitialized) {
@@ -146,6 +146,7 @@
         }
 
         err = executeGEMM(kargs,  numCommandQueues, commandQueues, 1, &firstHerkCall, events);
+        clReleaseEvent(firstHerkCall);
     }
 
     return (clblasStatus)err;
--- a/src/library/blas/xhpmv.c
+++ b/src/library/blas/xhpmv.c
@@ -44,7 +44,7 @@
 {
     cl_int err;
     ListHead seq1, seq2;
-	cl_event first_event;
+	cl_event first_event = NULL;
     clblasStatus retCode = clblasSuccess;
 
     if (!clblasInitialized) {
@@ -111,7 +111,8 @@
 				err = executeSolutionSeq(&seq2);
 			}
 			freeSolutionSeq(&seq2);
-		}
+            clReleaseEvent(first_event);
+        }
     }
 
     freeSolutionSeq(&seq1);
--- a/src/library/blas/xnrm2.c
+++ b/src/library/blas/xnrm2.c
@@ -35,7 +35,7 @@
 {
     cl_int err;
 	ListHead seq, seq2;
-    cl_event firstNrmCall;
+    cl_event firstNrmCall = NULL;
     CLBlasKargs redctnArgs;
     ListNode *listNodePtr;
     SolutionStep *step;
@@ -76,6 +76,7 @@
                 err = executeSolutionSeq(&seq2);
             }
             freeSolutionSeq(&seq2);
+            clReleaseEvent(firstNrmCall);
         }
     }
 
@@ -93,7 +94,7 @@
 {
     cl_int err;
 	ListHead seq, seq2;
-    cl_event firstNrmCall;
+    cl_event firstNrmCall = NULL;
     CLBlasKargs redctnArgs;
     ListNode *listNodePtr;
     SolutionStep *step;
@@ -134,6 +135,7 @@
                 err = executeSolutionSeq(&seq2);
             }
             freeSolutionSeq(&seq2);
+            clReleaseEvent(firstNrmCall);
         }
     }
 
--- a/src/library/blas/xspmv.c
+++ b/src/library/blas/xspmv.c
@@ -44,7 +44,7 @@
 {
     cl_int err;
     ListHead seq1, seq2;
-	cl_event first_event;
+	cl_event first_event = NULL;
     clblasStatus retCode = clblasSuccess;
 
     if (!clblasInitialized) {
@@ -113,7 +113,8 @@
 				err = executeSolutionSeq(&seq2);
 			}
 			freeSolutionSeq(&seq2);
-		}
+            clReleaseEvent(first_event);
+        }
     }
 
     freeSolutionSeq(&seq1);
--- a/src/library/blas/xtrsv.c
+++ b/src/library/blas/xtrsv.c
@@ -199,8 +199,8 @@
 	//
 	// Allocate Event Arrays to order the orchestration
 	//
-	triangleEventArray = malloc(nLoops*sizeof(cl_event));
-	rectangleEventArray = malloc(nLoops*sizeof(cl_event));
+	triangleEventArray = calloc(nLoops, sizeof(cl_event));
+	rectangleEventArray = calloc(nLoops, sizeof(cl_event));
 	if ((triangleEventArray == NULL) || (rectangleEventArray == NULL))
 	{
 		if (triangleEventArray)
@@ -289,8 +289,18 @@
 		}
 	}
 
-	free(triangleEventArray);
-	free(rectangleEventArray);
+    // Clean up internal events
+    for (i = 0; i < nLoops; i++)
+    {
+        clReleaseEvent(triangleEventArray[i]);
+        triangleEventArray[i] = NULL;
+        clReleaseEvent(rectangleEventArray[i]);
+        rectangleEventArray[i] = NULL;
+    }
+
+    free(triangleEventArray);
+    free(rectangleEventArray);
+
 	return err;
 }
 
